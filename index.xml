<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随笔</title><link>https://yuguo.im/</link><description>Recent content on 随笔</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Apr 2020 07:15:40 +0800</lastBuildDate><atom:link href="https://yuguo.im/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 中关于 iota 的 4 个例子</title><link>https://yuguo.im/post/2020/04/iota/</link><pubDate>Thu, 16 Apr 2020 07:15:40 +0800</pubDate><guid>https://yuguo.im/post/2020/04/iota/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/iota/
iota 基本示例 iota 关键字表示连续的整数常量0、1、2，&amp;hellip; 每当源代码中出现 const 关键字时，它将重置为 0， 并在每个 const 后按规范递增。 const ( C0 = iota C1 = iota C2 = iota ) fmt.Println(C0, C1, C2) // &amp;#34;0 1 2&amp;#34; 这可以简写为
const ( C0 = iota C1 C2 ) 这里我们依靠这样的事实，即表达式是在经过简化的 const 声明中隐式重复的 —— 这表示前面的表达式及其类型的重复。
从 1 开始 要以 1 而不是 0 开头的常量列表，可以在算术表达式中使用 iota。
const ( C1 = iota + 1 C2 C3 ) fmt.</description></item><item><title>How to use Excel with Go</title><link>https://yuguo.im/post/2020/04/golang-excel/</link><pubDate>Wed, 15 Apr 2020 18:52:12 +0800</pubDate><guid>https://yuguo.im/post/2020/04/golang-excel/</guid><description>Microsoft Excel™ (XLSX) 是广泛使用的一种电子表格格式。
Github 上有两个 Golang 包可以方便读写 Excel 文件。
360EntSecGroup-Skylar/excelize tealeg/xlsx Watch 170 180 Star 6k 4k Fork 652 657 包 360EntSecGroup-Skylar/excelize 比 tealeg/xlsx 关注度更高，并且 README.md 中有很多示例代码，下面就来看看这个包。
360EntSecGroup-Skylar/excelize 安装 go get github.com/360EntSecGroup-Skylar/excelize 创建 Excel 文档 官方示例 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/360EntSecGroup-Skylar/excelize&amp;quot; ) func main() { f := excelize.NewFile() // 创建一个工作表 index := f.NewSheet(&amp;quot;Sheet2&amp;quot;) // 设置单元格的值 f.</description></item><item><title>实现 PWA “可安装” 需要什么？</title><link>https://yuguo.im/post/2020/04/pwa-install/</link><pubDate>Tue, 14 Apr 2020 07:58:05 +0800</pubDate><guid>https://yuguo.im/post/2020/04/pwa-install/</guid><description>2020年2月14日发布 · 2020年2月24日更新
原文作者：Pete LePage
原文地址：https://web.dev/install-criteria/
许多浏览器会向用户表明，当您的渐进式 Web 应用程序（PWA）满足特定条件时，可以安装该程序。示例包括地址栏中的“安装”按钮或弹出菜单中的“安装”菜单项。另外，满足条件时，许多浏览器都会触发 beforeinstallprompt 事件，使您可以直接从 PWA 启用安装流程。
在 Chrome 浏览器中，您的 Progressive Web App 必须满足以下条件，才能触发 beforeinstallprompt 事件并显示浏览器内安装提示：
该 web app 尚未安装 满足用户启发式行为(引导页) 通过 HTTPS 提供服务 包括一个 Web App Manifest，其中包括 short_name 或 name icons - 必须包含 192px 和 512px 图标 start_url display - 必须是指定选项 fullscreen, standalone 或 minimal-ui 中的一个 注: prefer_related_applications 要么不存在，要么值为 false Registers a service worker with a functional fetch handler 其他浏览器具有类似的安装标准，尽管可能会有细微的差异。检查各个站点以获取完整详细信息：</description></item><item><title>Golang 中格式化时间或日期[完整指南]</title><link>https://yuguo.im/post/2020/04/format-parse-string-time-date-example/</link><pubDate>Mon, 13 Apr 2020 06:16:30 +0800</pubDate><guid>https://yuguo.im/post/2020/04/format-parse-string-time-date-example/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/format-parse-string-time-date-example/
基本例子 Go 不使用 yyyy-mm-dd 模式来格式化时间。而是，格式化一个特殊的参数
Mon Jan 2 15:04:05 MST 2006
与指定的时间或日期格式相同。(当写为 01/02 03:04:05 PM 06 -0700 时，这个日期更容易记住。美式的时间格式 月，日，时，分，秒，年排列起来依次是 1 2 3 4 5 6)
const ( layoutISO = &amp;quot;2006-01-02&amp;quot; layoutUS = &amp;quot;January 2, 2006&amp;quot; ) date := &amp;quot;1999-12-31&amp;quot; t, _ := time.Parse(layoutISO, date) fmt.Println(t) // 1999-12-31 00:00:00 +0000 UTC fmt.Println(t.Format(layoutUS)) // December 31, 1999 标准时间和日期格式 Go 格式模板 注释 January 2, 2006 Date 01/02/06 Jan-02-06 15:04:05 Time 3:04:05 PM Jan _2 15:04:05 Timestamp Jan _2 15:04:05.</description></item><item><title>Golang 中对切片或数组洗牌（译文）</title><link>https://yuguo.im/post/2020/03/shuffle-slice-array/</link><pubDate>Fri, 10 Apr 2020 16:08:23 +0800</pubDate><guid>https://yuguo.im/post/2020/03/shuffle-slice-array/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/shuffle-slice-array/
包 math/rand 中的 rand.Shuffle 函数使用给定的交换函数对输入序列进行混洗。
a := []int{1, 2, 3, 4, 5, 6, 7, 8} rand.Seed(time.Now().UnixNano()) rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] }) 输出：
[5 8 6 4 3 7 2 1] 警告：如果不调用 rand.Seed，则每次运行程序时，您都会获得相同的伪随机数序列。
延伸阅读 Golang 中生成随机数，字符和切片元素（译文）
Go 1.10 之前 在包 math/rand 中使用 rand.Seed 和 rand.Intn 函数。
a := []int{1, 2, 3, 4, 5, 6, 7, 8} rand.Seed(time.Now().UnixNano()) for i := len(a) - 1; i &amp;gt; 0; i-- { // Fisher–Yates shuffle j := rand.</description></item><item><title>Golang 中的 3 种排序方式（译文）</title><link>https://yuguo.im/post/2020/04/how-to-sort-in-go/</link><pubDate>Wed, 08 Apr 2020 07:57:31 +0800</pubDate><guid>https://yuguo.im/post/2020/04/how-to-sort-in-go/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/how-to-sort-in-go/
对整数，浮点数或字符串的切片进行排序 使用下面与其类型对应的方法
sort.Ints sort.Float64s sort.Strings s := []int{4, 2, 3, 1} sort.Ints(s) fmt.Println(s) // [1 2 3 4] 包 radix 是对 sort.Strings 的一种替代方案。在某些情况, 它可以快两倍以上。
用自定义比较器排序 使用函数 sort.Slice。它使用提供的功能 less(i, j int) bool 对切片进行排序。 要在保留相等元素的原始顺序的同时对切片进行排序，请改用 sort.SliceStable。 family := []struct { Name string Age int }{ {&amp;quot;Alice&amp;quot;, 23}, {&amp;quot;David&amp;quot;, 2}, {&amp;quot;Eve&amp;quot;, 2}, {&amp;quot;Bob&amp;quot;, 25}, } // Sort by age, keeping original order or equal elements.</description></item><item><title>10 个 Linux netstat 命令实战</title><link>https://yuguo.im/post/2020/03/linux-netstat-command-examples/</link><pubDate>Thu, 26 Mar 2020 07:47:50 +0800</pubDate><guid>https://yuguo.im/post/2020/03/linux-netstat-command-examples/</guid><description>作者：Silver Moon
原文网址：https://www.binarytides.com/linux-netstat-command-examples/
Netstat Netstat 是一个命令行实用程序，可用于列出系统上的所有网络（socket）连接。它列出了所有的 tcp，udp socket 连接和 unix socket 连接。
除了已连接的套接字外，它还可以列出正在等待传入连接的侦听套接字。因此，通过验证开放端口 80，可以确认 Web 服务器是否在系统上运行。这使得它成为网络和系统管理员非常有用的工具。
在本教程中，我们将查证一些示例，说明如何使用 netstat 查找有关网络连接和系统上开放端口的信息。
这是手册（man pages）中对 netstat 的简介
netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships 1. 列出所有连接 第一个也是最简单的命令是列出所有当前连接。只需使用 a 选项运行 netstat 命令。
$ netstat -a Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN tcp 0 0 localhost:ipp *:* LISTEN tcp 0 0 enlightened.</description></item><item><title>14 个重要的 Linux ps 命令实战</title><link>https://yuguo.im/post/2020/03/linux-ps-command-examples/</link><pubDate>Tue, 24 Mar 2020 08:01:37 +0800</pubDate><guid>https://yuguo.im/post/2020/03/linux-ps-command-examples/</guid><description>作者：Pungki Arianto
原文网址：https://linoxide.com/how-tos/linux-ps-command-examples/
Linux ps 命令是用于捕获系统上当前进程的内置工具。它将一次捕获系统状况。如果您想实时进行刷新，可以使用 top 命令。
在本教程中，我将向您展示 ps 命令的常见实际示例，该示例有助于您的日常linux系统管理。
1. 不带任何选项运行 ps 这是非常基本的 ps 用法。只需在控制台上键入 ps 即可查看其结果。
root@ParkW:~# ps PID TTY TIME CMD 28269 pts/1 00:00:00 bash 28307 pts/1 00:00:00 ps 默认情况下，它将向我们显示 4 列信息。
PID 是运行命令（CMD）的进程 ID TTY 是运行命令的地方 TIME 是运行命令时 CPU 使用了多少时间 CMD 是进程运行的命令 这里的信息展示是无序的。
2. 显示当前所有进程 为此，我们可以使用 -a 选项。我们可以猜到, -a 是 all 的简写。选项 x 将显示所有进程，即使当前进程也未与任何TTY（终端）相关联
$ ps -ax 该结果可能会比较多。为了使其更易于阅读，请将其与 less 命令结合使用。
$ ps -ax | less PID TTY STAT TIME COMMAND 1 ?</description></item><item><title>Golang 错误处理最佳实践（译文）</title><link>https://yuguo.im/post/2020/03/errors-explained/</link><pubDate>Thu, 19 Mar 2020 08:49:59 +0800</pubDate><guid>https://yuguo.im/post/2020/03/errors-explained/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/errors-explained/
Go 具有两种不同的错误处理机制：
大多数函数返回 errors； 只有真正无法恢复的条件（例如超出范围的索引）才会产生运行时异常，我们称之为 panic Go 的多值返回值使您可以轻松地在正常返回值旁边返回详细的错误消息。按照惯例，此类消息具有类型 error，这是一个简单的内置 interface：
type error interface { Error() string } 错误处理示例 os.Open 函数无法打开文件时返回一个非 nil 错误值。
func Open(name string) (file *File, err error) 以下代码使用 os.Open 打开文件。如果发生错误，它将调用 log.Fatal 打印错误消息并停止。
f, err := os.Open(&amp;quot;filename.ext&amp;quot;) if err != nil { log.Fatal(err) } // do something with the open *File f 自定义错误 要创建简单的仅字符串 error，可以使用 errors.New：
err := errors.New(&amp;quot;Houston, we have a problem&amp;quot;) error 接口仅需要一个 Error 方法，但是特定的 error 实现通常具有其他方法，从而允许调用方检查错误的详细信息。</description></item><item><title>Panic,堆栈跟踪以及如何恢复【最佳实践】（译文）</title><link>https://yuguo.im/post/2020/03/recover-from-panic/</link><pubDate>Thu, 19 Mar 2020 08:47:34 +0800</pubDate><guid>https://yuguo.im/post/2020/03/recover-from-panic/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/recover-from-panic/
Panic 是 Go 中的一个异常 Panics 类似于 C++ 和 Java 异常，但仅适用于运行时错误，例如跟随一个 nil 指针或试图对数组访问超出范围的索引。为了表示诸如文件结束之类的事件，Go 程序使用内置 error 类型。有关错误的更多信息，请参见 错误处理最佳实践 和 3种创建错误的简单方法。
Panic 停止 goroutine 的正常执行
程序出现 panic 时，它将立即开始展开调用堆栈。 一直持续到程序崩溃并打印堆栈跟踪, 或直到调用内置的恢复功能。 panic 是由运行时错误或对内置函数 panic 的显式调用引起的。
堆栈跟踪记录 堆栈跟踪记录 —— 所有活动堆栈帧的报告 —— 通常在 panic 发生时将其打印到控制台。堆栈跟踪对于调试非常有用：
您不仅可以看到错误发生的地方， 而且可以看到程序是如何到达这个地方的。 解释堆栈跟踪 这是一个堆栈跟踪的示例：
goroutine 11 [running]: testing.tRunner.func1(0xc420092690) /usr/local/go/src/testing/testing.go:711 +0x2d2 panic(0x53f820, 0x594da0) /usr/local/go/src/runtime/panic.go:491 +0x283 github.com/yourbasic/bit.(*Set).Max(0xc42000a940, 0x0) ../src/github.com/bit/set_math_bits.go:137 +0x89 github.com/yourbasic/bit.TestMax(0xc420092690) ../src/github.com/bit/set_test.go:165 +0x337 testing.tRunner(0xc420092690, 0x57f5e8) /usr/local/go/src/testing/testing.</description></item><item><title>Golang 中 3 种简单的方法来创建错误（译文）</title><link>https://yuguo.im/post/2020/03/create-error/</link><pubDate>Thu, 19 Mar 2020 08:28:05 +0800</pubDate><guid>https://yuguo.im/post/2020/03/create-error/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/create-error/
基于字符串的错误 标准库提供了两个现成的选项。
// simple string-based error err1 := errors.New(&amp;quot;math: square root of negative number&amp;quot;) // with formatting err2 := fmt.Errorf(&amp;quot;math: square root of negative number %g&amp;quot;, x) 带有数据的自定义错误 要定义自定义错误类型，您必须满足预先声明的 error 接口。
type error interface { Error() string } 这里有两个例子。
type SyntaxError struct { Line int Col int } func (e *SyntaxError) Error() string { return fmt.Sprintf(&amp;quot;%d:%d: syntax error&amp;quot;, e.Line, e.Col) } type InternalError struct { Path string } func (e *InternalError) Error() string { return fmt.</description></item><item><title>Golang 中将接口转换为字符串（译文）</title><link>https://yuguo.im/post/2020/03/interface-to-string/</link><pubDate>Sun, 15 Mar 2020 20:33:15 +0800</pubDate><guid>https://yuguo.im/post/2020/03/interface-to-string/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/interface-to-string/
使用 fmt.Sprintf 将interface value转换为字符串。
var x interface{} = &amp;quot;abc&amp;quot; str := fmt.Sprintf(&amp;quot;%v&amp;quot;, x) 实际上，可以使用相同的技术来获取任何数据结构的字符串表示形式。
var x interface{} = []int{1, 2, 3} str := fmt.Sprintf(&amp;quot;%v&amp;quot;, x) fmt.Println(str) // &amp;quot;[1 2 3]&amp;quot; Fmt 备忘单 顶级 fmt 格式化技巧</description></item><item><title>Golang 中 crypto/rand（译文）</title><link>https://yuguo.im/post/2020/03/crypto-rand-int/</link><pubDate>Sun, 15 Mar 2020 16:08:45 +0800</pubDate><guid>https://yuguo.im/post/2020/03/crypto-rand-int/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/crypto-rand-int/
Go 有两个用于随机数的包：
math/rand 实现了大量伪随机数生成器。 crypto/rand 实现了具有受限接口的加密安全伪随机数生成器。 这两个包可以通过调用包 math/rand 中的 rand.New 与一个从 crypto/rand 获取数据的源来合并。
import ( crand &amp;#34;crypto/rand&amp;#34; rand &amp;#34;math/rand&amp;#34; &amp;#34;encoding/binary&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; ) func main() { var src cryptoSource rnd := rand.New(src) fmt.Println(rnd.Intn(1000)) // a truly random number 0 to 999 } type cryptoSource struct{} func (s cryptoSource) Seed(seed int64) {} func (s cryptoSource) Int63() int64 { return int64(s.Uint64() &amp;amp; ^uint64(1&amp;lt;&amp;lt;63)) } func (s cryptoSource) Uint64() (v uint64) { err := binary.</description></item><item><title>Golang 中生成唯一的字符串（UUID，GUID）(译文)</title><link>https://yuguo.im/post/2020/03/generate-uuid-guid/</link><pubDate>Sun, 15 Mar 2020 15:48:09 +0800</pubDate><guid>https://yuguo.im/post/2020/03/generate-uuid-guid/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/generate-uuid-guid/
通用唯一标识符 UUID（universally unique identifier）或全局唯一标识符 GUID （globally unique identifier）是用于标识信息的 128 位数字。
UUID 是唯一的(出于实用目的)：它重复的概率非常接近零。 UUID 不依赖中央机构的注册和分配。 UUID 的字符串表示形式由 32 个十六进制数字组成，以 5 个组显示，由连字符 - 分隔。例如：
123e4567-e89b-12d3-a456-426655440000 UUID 生成器示例 您可以使用来自 crypto/rand 包的 rand.Read 函数来生成基本的 UUID。
b := make([]byte, 16) _, err := rand.Read(b) if err != nil { log.Fatal(err) } uuid := fmt.Sprintf(&amp;#34;%x-%x-%x-%x-%x&amp;#34;, b[0:4], b[4:6], b[6:8], b[8:10], b[10:]) fmt.Println(uuid) 输出：
9438167c-9493-4993-fd48-950b27aad7c9 局限性 此 UUID 不符合 RFC4122。特别是，它不包含任何版本号或变体号。
警告：如果系统底层调用失败，则 rand.</description></item><item><title>软件公寓疫情退租指北</title><link>https://yuguo.im/post/2020/03/rent-refund/</link><pubDate>Sun, 15 Mar 2020 11:54:58 +0800</pubDate><guid>https://yuguo.im/post/2020/03/rent-refund/</guid><description> 自 2020 年 3 月 12 日收到通知，免收 2020 年 2 月 1 日 —— 2020 年 4 月 30 日 期间三个月的租金，实际减免租金标准按租赁协议为准，主申请人于 3 月 12 日起，到小区物业前台核验身份证并签字，确认。
在实际操作过程中有些小麻烦，不过都克服了，我把它们记录下来，方便大家少踩坑。
物业上班时间 早： 8:30 —— 12:00
下午：13:30 —— 17:00
准备材料 身份证原件及复印件（多打印几份，备用） 银行卡原件及复印件（多打印几份，备用） 注意: 银行卡需要提前获取对应的开户行信息，到时物业会要求你填写，不清楚的就打对应银行的客户电话（我因为没有提前准备在那耽搁了很长时间）
最近一个季度的收据，也就是对应免租期间的收据。 注意：如果找不到收据，也没有关系，准备好一份声明，这份声明写在身份证复印件的背面（这里我又踩了一个坑，誊写时由于时早上排队时写的，比较潦草，人家拒绝接受，另外尽量保持字迹工整，不能有修改，写的时候细心一点），下面是声明的内容。(下图有个信息是错误的，地址不对，应该是软件公寓 A 区，不是 D 区) 其他 即使减免租金了，物业费少不了，到时需要缴纳物业费； 去年 3 月份签订了再延期一年的同志们，即使不要求退款，4 月 30 日之前必须退房，无法延期； 周末办理这个手续的人比较多，大家看好自己的时间，我排队大概花了 40 分钟才轮到我 退租金相关资料 退房相关手续相关资料</description></item><item><title>那些年，一起杀草莓的日子</title><link>https://yuguo.im/post/2020/03/2019-march/</link><pubDate>Sat, 14 Mar 2020 12:00:33 +0800</pubDate><guid>https://yuguo.im/post/2020/03/2019-march/</guid><description>去年的三月份，算是踏入初春，天气微热，百花盛开，正是踏青的好时节。我们一起去“杀”草莓。
First blood Double kill Legendary Lovey dovey</description></item><item><title>Golang 中生成随机数，字符和切片元素（译文）</title><link>https://yuguo.im/post/2020/03/generate-number-random-range/</link><pubDate>Fri, 13 Mar 2020 08:19:52 +0800</pubDate><guid>https://yuguo.im/post/2020/03/generate-number-random-range/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/generate-number-random-range/
Go 伪随机数基础知识 使用包 math/rand 中的 rand.Seed 和 rand.Int63 函数生成 int64 类型的非负伪随机数：
rand.Seed(time.Now().UnixNano()) n := rand.Int63() // for example 4601851300195147788 同样，rand.Float64 生成伪随机浮点数 x，其中 0 ≤ x &amp;lt; 1：
x := rand.Float64() // for example 0.49893371771268225 警告：如果不先调用 rand.Seed，则每次运行该程序时，都会得到相同的数字序列。
请参阅随机数生成器中的种子是什么?, 解释伪随机数生成器的原理。
几个随机源 math/rand 包中的函数全部使用单个随机源。
如果需要，您可以使用自己的源创建一个新的 Rand 类型的随机生成器，然后使用其方法生成随机数：
generator := rand.New(rand.NewSource(time.Now().UnixNano())) n := generator.Int63() x := generator.Float64() 给定范围内的整数和字符 a 和 b 之间的数字 使用 rand.Intn(m)，它返回一个伪随机数 n，其中 0 ≤ n &amp;lt; m。</description></item><item><title>Golang 中生成密码（译文）</title><link>https://yuguo.im/post/2020/03/generate-random-string/</link><pubDate>Thu, 12 Mar 2020 08:27:26 +0800</pubDate><guid>https://yuguo.im/post/2020/03/generate-random-string/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/generate-random-string/
随机字符串 该代码从瑞典语字母（包括非 ASCII 字符 å， ä 和 ö ）中生成一个随机的数字和字符字符串。
rand.Seed(time.Now().UnixNano()) chars := []rune(&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ&amp;#34; + &amp;#34;abcdefghijklmnopqrstuvwxyzåäö&amp;#34; + &amp;#34;0123456789&amp;#34;) length := 8 var b strings.Builder for i := 0; i &amp;lt; length; i++ { b.WriteRune(chars[rand.Intn(len(chars))]) } str := b.String() // E.g. &amp;#34;ExcbsVQs&amp;#34; 警告：要生成密码，应使用加密安全的伪随机数。请参阅 User-friendly access to crypto/rand。
有限制的随机字符串 此代码生成一个随机的 ASCII 字符串，该字符串至少包含一个数字和一个特殊字符。
rand.Seed(time.Now().UnixNano()) digits := &amp;#34;0123456789&amp;#34; specials := &amp;#34;~=+%^*/()[]{}/!@#$?|&amp;#34; all := &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34; + &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; + digits + specials length := 8 buf := make([]byte, length) buf[0] = digits[rand.</description></item><item><title>Golang 中 int，int64 和字符串互转（译文）</title><link>https://yuguo.im/post/2020/03/convert-int-to-string/</link><pubDate>Wed, 11 Mar 2020 19:40:30 +0800</pubDate><guid>https://yuguo.im/post/2020/03/convert-int-to-string/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/convert-int-to-string/
int/int64 转字符串 使用 strconv.Itoa 将 int 转换为十进制字符串。
s := strconv.Itoa(97) // s == &amp;quot;97&amp;quot; 警告：在普通转换中，该值将解释为 Unicode 码位，并且生成的字符串将包含该码位表示的字符，并以 UTF-8 编码。
s := string(97) // s == &amp;quot;a&amp;quot;
使用 strconv.FormatInt 以给定的进制数（十进制、十六进制）格式化 int64。
var n int64 = 97 s := strconv.FormatInt(n, 10) // s == &amp;quot;97&amp;quot; (十进制) var n int64 = 97 s := strconv.FormatInt(n, 16) // s == &amp;quot;61&amp;quot; (十六进制) 字符串转 int/int64 使用 strconv.Atoi 将十进制字符串解析为 int 。</description></item><item><title>Golang 中字符串和浮点数互转（译文）</title><link>https://yuguo.im/post/2020/03/convert-string-to-float/</link><pubDate>Wed, 11 Mar 2020 19:33:24 +0800</pubDate><guid>https://yuguo.im/post/2020/03/convert-string-to-float/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/convert-string-to-float/
字符串转为浮点数 使用 strconv.ParseFloat 函数将字符串解析为浮点数, 通过指定参数 bitSize 的值来确定精度：float32 为 32，float64 为 64。
func ParseFloat(s string, bitSize int) (float64, error) 当 bitSize 为 32 时，结果仍为 float64 类型，但可以将其转换为 float32 而无需更改其值。
f := &amp;quot;3.14159265&amp;quot; if s, err := strconv.ParseFloat(f, 32); err == nil { fmt.Println(s) // 3.1415927410125732 } if s, err := strconv.ParseFloat(f, 64); err == nil { fmt.Println(s) // 3.14159265 } 浮点数转为字符串 使用 fmt.Sprintf 方法将浮点数格式化为字符串。
s := fmt.Sprintf(&amp;quot;%f&amp;quot;, 123.</description></item><item><title>Golang 中字节切片/数组和字符串互转（译文）</title><link>https://yuguo.im/post/2020/03/convert-string-to-byte-slice/</link><pubDate>Wed, 11 Mar 2020 18:20:48 +0800</pubDate><guid>https://yuguo.im/post/2020/03/convert-string-to-byte-slice/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/convert-string-to-byte-slice/
基本认知 在字符串和字节切片（数组）之间进行转换时，会得到一个全新的切片，其中包含与字符串相同的字节，反之亦然。
转换不会修改数据 唯一的区别是字符串是不可变的，而字节片可以修改 如果需要操纵字符串的 rune ，则可能需要将字符串转换为 rune 切片，更多细节请看这篇文章 Golang 中 runes 和 字符串互转（译文）
将字符串转为字节切片 将字符串转换为字节切片时，会得到一个新的切片，其中包含与字符串相同的字节。
b := []byte(&amp;quot;ABC€&amp;quot;) fmt.Println(b) // [65 66 67 226 130 172] 请注意，字符 € 是使用 3 个字节的 UTF-8 编码的。有关 Unicode 码位的 UTF-8 编码的更多信息，请参阅关于 rune 的这篇文章。
将字节切片转为字符串 当您将字节的一部分转换为字符串时，您将获得一个新的字符串，其中包含与该片段相同的字节。
s := string([]byte{65, 66, 67, 226, 130, 172}) fmt.Println(s) // ABC€ 性能 这些转换将创建一个新的切片或字符串，因此时间复杂度与处理的字节数成正比。</description></item><item><title>Golang 中 runes 和 字符串互转（译文）</title><link>https://yuguo.im/post/2020/03/convert-string-to-rune-slice/</link><pubDate>Wed, 11 Mar 2020 08:26:57 +0800</pubDate><guid>https://yuguo.im/post/2020/03/convert-string-to-rune-slice/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/convert-string-to-rune-slice/
Convert string to runes 将字符串转换为 rune 切片时，会得到一个新的切片，其中包含字符串的 Unicode 码位( runes ) 对于无效的 UTF-8 序列，每个无效字节的 rune 值将为 0xFFFD。 r := []rune(&amp;quot;ABC€&amp;quot;) fmt.Println(r) // [65 66 67 8364] fmt.Printf(&amp;quot;%U\n&amp;quot;, r) // [U+0041 U+0042 U+0043 U+20AC] 您还可以使用 range 循环访问字符串的码位。
Convert runes to string 当您将一小段 runes 转换为字符串时，会得到一个新字符串，该字符串是将 runes 转换为 UTF-8 编码字符串的串联。 有效 Unicode 码位范围之外的值将转换为 Unicode 替换字符\uFFFD, 显示为�。 s := string([]rune{'\u0041', '\u0042', '\u0043', '\u20AC', -1}) fmt.</description></item><item><title>Runes 和字符编码（译文）</title><link>https://yuguo.im/post/2020/03/rune/</link><pubDate>Tue, 10 Mar 2020 19:00:17 +0800</pubDate><guid>https://yuguo.im/post/2020/03/rune/</guid><description>作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/rune
字符，ASCII 和 Unicode rune 类型是 int32 的别名，用于强调其代表的是码位（code point），而不是整数。
ASCII 定义 128 个字符，由码位 0 – 127 标识。它涵盖英文字母，拉丁数字和其他一些字符。
Unicode 是 ASCII 的超集，它定义了 1,114,112 个代码点的代码空间。 Unicode 版本 10.0 涵盖 139 个现代和历史文本集（包括符文字母，但不包括 Klingon ）以及多个符号集。
字符串和 UTF-8 编码 字符串是字节序列，而不是符文。
但是，字符串通常包含以 UTF-8 编码的 Unicode 文本，该文本使用一到四个字节对所有 Unicode 码位进行编码。（ASCII 字符使用一个字节编码，而其他码位则使用更多字节。）
由于 Go 源代码本身被编码为 UTF-8，因此字符串文字将自动获得此编码。
例如，在字符串&amp;quot;café&amp;quot;中，字符é（码位 233）使用两个字节编码，而 ASCII 字符 c，a 和 f（码位 99、97 和 102）仅使用一个字节：
fmt.Println([]byte(&amp;quot;café&amp;quot;)) // [99 97 102 195 169] fmt.</description></item><item><title>Golang 中类型断言和类型切换（译文）</title><link>https://yuguo.im/post/2020/03/type-assertion-switch/</link><pubDate>Tue, 10 Mar 2020 07:55:40 +0800</pubDate><guid>https://yuguo.im/post/2020/03/type-assertion-switch/</guid><description>类型断言提供对接口具体值的访问。
作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/type-assertion-switch/
类型断言 类型断言并不能真正将 interface 转换为另一种数据类型，但是可以访问 interface 的具体值，而这正是您所希望的。
类型断言 x.(T) 断言 x 中存储的具体值是 T 类型，并且 x 不为 nil
如果 T 不是 interface，则断言 x 的动态类型与 T 相同 如果 T 是 interface，则断言 x 的动态类型实现了 T var x interface{} = &amp;quot;foo&amp;quot; var s string = x.(string) fmt.Println(s) // &amp;quot;foo&amp;quot; s, ok := x.(string) fmt.Println(s, ok) // &amp;quot;foo true&amp;quot; n, ok := x.(int) fmt.Println(n, ok) // &amp;quot;0 false&amp;quot; n = x.</description></item><item><title>如何在 Go 中使用 JSON【最佳实践】（译文）</title><link>https://yuguo.im/post/2020/03/go-json/</link><pubDate>Tue, 03 Mar 2020 10:42:18 +0800</pubDate><guid>https://yuguo.im/post/2020/03/go-json/</guid><description>JSON 数据交换格式对人类来说很容易读写，对机器进行解析和生成也非常有效。
作者：Stefan Nilsson
原文网址：https://yourbasic.org/golang/json-example/
默认类型 用于解码和编码 JSON 的默认 Go 类型是
Go JSON bool booleans float64 numbers string strings nil null 另外，可以将 math.big 包中的 time.Time 和数字类型自动编码为JSON字符串。
请注意，JSON不支持基本整数类型。它们通常可以用浮点数来近似。
由于实现 IEEE 754-2008 binary64（双精度）数字的软件普遍可用并得到广泛使用，因此，期望其精度或范围不超过其提供的精度的实现可以实现良好的互操作性。
请注意，使用此类软件时，在实现将完全一致于其数值的意义上，整数（整数）且在 $\ce{[-2^53 + 1, 2^53 - 1]}$ 范围内是可以互操作的。
RFC 7159: JSON数据交换格式
编码(marshal) struct 转 JSON 包 encoding/json 中的 json.Marshal 函数生成JSON数据。</description></item><item><title>关于我</title><link>https://yuguo.im/about/</link><pubDate>Sat, 15 Feb 2020 21:25:35 +0000</pubDate><guid>https://yuguo.im/about/</guid><description>个人信息 雨果 / 男 / 1993 本科 2015.5 上线 博客: https://yuguo.im Github: https://github.com/xiayuguo 技能清单 Python / Golang Flask / Tornado / Celery / Gin Nginx / Caddy Postgres / Mysql / Mongodb / Redis RabbitMQ / Mosquitto Docker 职业信条 语言本身并不重要，解决问题的创新方法才是王道
联系方式 Email: hi@yuguo.im</description></item><item><title>Microsoft Visual C++ 14.0 is required</title><link>https://yuguo.im/post/2019/08/cpluspuls14-required/</link><pubDate>Mon, 26 Aug 2019 18:46:44 +0800</pubDate><guid>https://yuguo.im/post/2019/08/cpluspuls14-required/</guid><description>在Windows系统上安装某些需要编译的包时经常会遇到这个问题，经常使用的办法是找一个编译好的版本直接通过pip安装，但是找不到怎么办?
省时省力，第一优先级 Python Extension Packages for Windows: https://www.lfd.uci.edu/~gohlke/pythonlibs/
安装C编译环境 失败经历 先附上我的失败经历，希望直接看到成功的，直接下拉到最后。
1. 利用python包的错误提示信息 Microsoft Visual C++ 14.0 is required. Get it with &amp;quot;Microsoft Visual C++ Build Tools&amp;quot;: https://visualstudio.microsoft.com/downloads/ 这个网站把2015、2017版本给隐藏起来，找起来比较麻烦。 看这里所有的旧版本都在这: https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/ 2. python版本和对应的C++编译版本 https://wiki.python.org/moin/WindowsCompilers
Visual C++ CPython 14.X 3.5, 3.6, 3.7, 3.8 10.0 3.3, 3.4 9.0 2.6, 2.7, 3.0, 3.1, 3.2 3. 我把2019, 2017, 2015版本(均高于14.</description></item><item><title>Change Redis Password</title><link>https://yuguo.im/post/2019/07/change-redis-password/</link><pubDate>Mon, 22 Jul 2019 18:36:32 +0800</pubDate><guid>https://yuguo.im/post/2019/07/change-redis-password/</guid><description>Ubuntu 修改配置文件 /etc/redis/redis.conf requirepass 你的密码 重启 redis 服务 service redis restart Win10 修改配置文件 C:\Program Files\Redis\redis.windows-service.conf requirepass 你的密码 重启 redis 服务 net stop redis net start redis 注: 这两个操作都需要以管理员身份权限
实时生效(免重启) 启动 redis 客户端 redis-cli 127.0.0.1:6379&amp;gt; config set requirepass 你的密码 注: 这种方式确实是实时生效，但是一旦重启后，这种配置就丢失了，以配置文件为准, 因为它并没有被持久化到文件中。
参考文档 set a password for redis 莫博客</description></item><item><title>Change Mysql Password</title><link>https://yuguo.im/post/2019/07/change-mysql-password/</link><pubDate>Wed, 17 Jul 2019 19:02:58 +0800</pubDate><guid>https://yuguo.im/post/2019/07/change-mysql-password/</guid><description>去年的这个夏天，不像今年雨水很多，天气微热，朋友打电话过来说: “他的数据库被人黑了，对方扬言必须给某某账号下转xxx比特币，不然就删库”。修改数据库密码有三种常见方式：mysqladmin和sql。
修改数据库密码前，我们先来看下数据库里存储的用户和密码信息，此处示例中我使用的密码是666, 要修改为999。
mysql&amp;gt; select host,user,password from mysql.user where user=&amp;quot;root&amp;quot;; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | hugo | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | 127.0.0.1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | ::1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | % | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | +-----------+------+-------------------------------------------+ 5 rows in set (0.00 sec) 方式一 mysqladmin -uroot -p666 flush-privileges password &amp;quot;999&amp;quot; 可以通过下面的方式来验证：</description></item><item><title>Difference Between The 'history' Command and 'cat ~/.bash_history'</title><link>https://yuguo.im/post/2019/07/history-and-history-file/</link><pubDate>Fri, 05 Jul 2019 20:35:16 +0800</pubDate><guid>https://yuguo.im/post/2019/07/history-and-history-file/</guid><description>寻找这个问题的答案时，无意间看到1999年的一段对话，完美的解释了我的疑问。通过操作验证，David 说的 100% 正确。 如果别人问起我这个问题，我也会以他的原话来回答，因为我找不到比他回答得更完美的答案了。
History for your current shell is retained in RAM. It is appended to .bash_history (subject to the length you define for that file) when you exit the shell. Therefore, cat ~/.bash_history will always be as current as the LAST shell you ran, and its last entry should be &amp;ldquo;exit&amp;rdquo;.
Commands run in the current shell won&amp;rsquo;t appear there yet.
History for your current shell is retained in RAM.</description></item><item><title>History Usage</title><link>https://yuguo.im/post/2019/07/history-usage/</link><pubDate>Thu, 04 Jul 2019 22:28:57 +0800</pubDate><guid>https://yuguo.im/post/2019/07/history-usage/</guid><description>history 命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。
该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入 !2。
历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。
语法 history(选项)(参数) 选项 -c：清空当前历史命令； -a：将历史命令缓冲区中命令写入历史命令文件中； -r：将历史命令文件中的命令读入当前历史命令缓冲区； -w：将当前历史命令缓冲区命令写入历史命令文件中。 参数 n：打印最近的n条历史命令。 实例 使用history命令显示最近使用的10条历史命令，输入如下命令：
[root@localhost ~]# history 10 92 ls 93 cd .. 94 ls 95 exit 96 ls -a 97 cd .ssh/ 98 ls 99 cat known_hosts 100 exit 101 history 10 其他特殊技巧 使用 HISTTIMEFORMAT 显示时间戳 export HISTTIMEFORMAT='%F %T ' 注意：这个功能只能用在当 HISTTIMEFORMAT 这个环境变量被设置之后，之后的那些新执行的 bash 命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置 HISTTIMEFORMAT 变量的时间。可以在 .bash_profile 中把这条设置指令添加进去，后面就可以一直使用了。
使用 Ctrl + R 查询历史记录 动手试试，超级便利。</description></item><item><title>Tar压缩命令小结</title><link>https://yuguo.im/post/2019/07/tar-zip-summary/</link><pubDate>Tue, 02 Jul 2019 18:40:09 +0800</pubDate><guid>https://yuguo.im/post/2019/07/tar-zip-summary/</guid><description>今天遇到一个麻烦，从生产环境备份的一个SQL脚本，体积是705M，希望下载到本地做测试，由于网络不稳定、带宽有限等问题，无法下载成功，于是怎么办？压缩！
root@localhost:/home/test# ls -lh total 705M -rw-r--r-- 1 root root 705M 7月 2 09:48 bf_2019_07-02.sql 我们先来回顾下压缩/解压缩相关常用命令
Tar -c create 简写, 创建压缩 -x extract 简写, 提取压缩 -f 生成的文件名 -z 以gzip方式压缩 -j 以bzip2方式压缩 -J 以xz方式压缩 -t list 简写, 列出压缩的内容 -v verbose 简写, 详细列出已处理的文件 示例 Tar 压缩 tar -czf a.tar.gz a.sql tar -cjf a.tar.bz2 a.sql tar -cJf a.tar.xz a.sql Tar 解压缩 tar -xzf a.tar.gz tar -xjf a.</description></item><item><title>Export Mysql Table to Excel</title><link>https://yuguo.im/post/2019/07/export-mysql-table-to-excel/</link><pubDate>Mon, 01 Jul 2019 12:13:24 +0800</pubDate><guid>https://yuguo.im/post/2019/07/export-mysql-table-to-excel/</guid><description>今天有同事问我怎么把Mysql某个表中的数据导出到Excel中？本以为so easy的事，结果踩了很多坑，记录下。
方法一: 使用MySQL Workbench导出CSV MySQL Workbench 这个客户端软件是我一直使用的一款 MySQL 客户端, 超级强大。自然也少不了导入和导出的功能。具体导出的步骤请移步至官方文档(图文并茂, 美滴很)
在准备享受胜利果实的时候，使用Excel打开导出的CSV文件，我去，中文全都是乱码，怎么办呢？
甭捉急，两步搞定乱码问题:
使用记事本打开上述的CSV文件 文件 =&amp;gt; 另存为 =&amp;gt; 选中编码为ANSI =&amp;gt; 最后覆盖原文件，就好了 方法二: 使用原生SQL导出CSV 万变不离其宗，SQL 是一种更加原始粗暴的方案，但是更加实用，即使再花哨的工具，最后归根结底还是会回到这个位置。
语法 SELECT * FROM 表名 INTO OUTFILE '输出的文件位置' FIELDS TERMINATED BY '字段分隔符(,)' ENCLOSED BY '字段包围符(&amp;quot;)' LINES TERMINATED BY '行间分隔符(\n)'; 理想很丰满，现实很骨感。有了语法，执行时又遇到问题了。
问题一: secure-file-priv选项问题 ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 使用的MySQL版本5.</description></item><item><title>Linux Shell Shortcut</title><link>https://yuguo.im/post/2019/linux-shell-shortcut/</link><pubDate>Sun, 30 Jun 2019 22:49:57 +0800</pubDate><guid>https://yuguo.im/post/2019/linux-shell-shortcut/</guid><description>作为一名键盘控，提升十倍效率的快捷键。
Ctrl + U – 剪切光标前的内容 Ctrl + K – 剪切光标至行末的内容 Ctrl + Y – 粘贴 Ctrl + E – 移动光标到行末 (End) Ctrl + A – 移动光标到行首(Ahead) ALT + F – 跳向下一个空格 (Front) ALT + B – 跳回上一个空格 (Back) ALT + Backspace – 删除前一个单词 Ctrl + W – 剪切光标前一个单词 (Word) Ctrl + Insert – 复制 Shift + Insert – 粘贴 更多Linux常用快捷键及命令总结参见这里</description></item><item><title>无法将所做的改动保存到 chrome lnk</title><link>https://yuguo.im/post/2019/chrome-startup-auto-redirect-hao123/</link><pubDate>Sun, 30 Jun 2019 21:25:07 +0800</pubDate><guid>https://yuguo.im/post/2019/chrome-startup-auto-redirect-hao123/</guid><description> 昨天把旧电脑取出来，给它充放电。恰巧要查点资料，顺手打开谷歌浏览器，我去，怎么一上来就是hao123？
我的第一反应就是某个软件改写了Chrome的设置。
1. 查询设置 启动时 打开新标签页 从上次停下的地方继续 打开特定网页或一组网页 添加新网页 使用当前网页 没有任何异常，没有植入hao123网址
2. 右键Chrome快捷方式查看属性 目标(T): &amp;quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&amp;quot; http://www.hao123.com 起始位置(S): &amp;quot;C:\Program Files (x86)\Google\Chrome\Application&amp;quot; 果然罪魁祸首在这里，把后面的网址删除后，提示: 无法将所做的改动保存到 chrome lnk
3. 解决方案 删除Chrome快捷方式 拷贝 起始位置(S) 到地址栏 找到 chrome.exe, 重新创建快捷方式</description></item><item><title>Extracting MAC address using Python</title><link>https://yuguo.im/post/2019/extra-mac-address-using-python/</link><pubDate>Sat, 29 Jun 2019 15:11:07 +0800</pubDate><guid>https://yuguo.im/post/2019/extra-mac-address-using-python/</guid><description>使用 Python 来提取计算机的 MAC 地址。翻译来源: https://www.geeksforgeeks.org/extracting-mac-address-using-python/
MAC地址也称为物理地址，是分配给计算机网卡(NIC)的唯一标识符。NIC有助于将计算机与网络中的其他计算机连接。 MAC地址对于所有NIC都是唯一的。
MAC地址的用途：
在IP地址频繁更改的地方很有用。帮助网络管理员。获取有关网络流量的信息。 帮助我们配置哪些计算机可以连接到我们的计算机。通过这种方式我们可以过滤潜在的垃圾邮件/病毒攻击。 帮助从世界各地的其他计算机中唯一识别计算机。 Example MAC Address 00 16 2C 99 0B DB |______| |______| | | Vendor No Serial No 方法1：使用 uuid.getnode() getnode() 可用于提取计算机的MAC地址。该方法在uuid模块中定义。 下面给出的插图代码显示了如何使用uuid1（）函数为给定主机生成UUID，该UUID由其MAC地址标识。
代码: ## Python Program to compute ## MAC address of host ## using UUID module import uuid ## printing the value of unique MAC ## address using uuid and getnode() function print(hex(uuid.getnode())) 输出: 0x163e990bdb 缺点: 显而易见的缺点是“输出不是格式化的形式”。 方法2：使用getnode() + format()[为了更好的格式化形式] 代码: ## Python 3 code to print MAC ## in formatted way.</description></item><item><title>还在找U盘？别找了，我教你一招！</title><link>https://yuguo.im/post/2019/replace-flash-disk/</link><pubDate>Sat, 01 Jun 2019 23:22:26 +0800</pubDate><guid>https://yuguo.im/post/2019/replace-flash-disk/</guid><description>最近有同事问我，有没有U盘，她要给别人拷下文件，或者是从别人那拷贝下文件。
这些文件普遍有个特点就是体积大（超出微信客户端中的上限 100M）
办公室里这种小事时常发生，时间就在指缝间悄悄流逝。
作为一名 “懒人”，这种事要是发生在身上，我会这么解决：
准备工作 发送方和接收方在一个局域网内 发送方的 PC 上有 python 环境 开始我的表演 以 Win10 系统演示，其他系统方法类似
Step.1 发送方进入要传递文件的目录
Step.2 地址栏输入cmd
Step.3 输入指令ipconfig，获得ipv4地址，假设你获得的是192.168.1.10
Step.4 确认系统环境的python版本，不同版本输入不同的指令，请对号入座。
python2 python -m SimpleHTTPServer python3 python -m http.server Step.5 此时防火墙会有提示，选择允许访问
Step.6 接收方打开任意浏览器，输入http:192.168.1.10:8000，页面上立马会返回Step.1中看到的目录，此时就已经大功告成了。
新的旅程 技术的诞生是因为问题需要得到解决，然而解决问题的方案永远不止一种，此时应在特定的场景下寻求最优解，不局限某种方法，不固步自封，勇于尝试各种思路。从这周开始，每一周的周末，我都会和大家分享，日常工作生活学习中遇到的各种问题，以及我是怎么解决的，不求给大家多大的帮助，但求拓宽解决问题的思路。</description></item><item><title>View Memory Information Using the Command Line in Win10</title><link>https://yuguo.im/post/2019/03/view-mem-info-in-win10/</link><pubDate>Thu, 21 Mar 2019 18:39:28 +0800</pubDate><guid>https://yuguo.im/post/2019/03/view-mem-info-in-win10/</guid><description> 通过命令行查看内存条信息
步骤一: 打开命令行模式 方式一: Win + R 打开运行，输入cmd回车; 方式二: Win + S 打开搜索，输入cmd回车; 步骤二: 命令行模式下输入wmic C:\Users\Hugo&amp;gt;wmic wmic:root\cli&amp;gt; 步骤三: 继续输入memorychip wmic:root\cli&amp;gt;memorychip ... Capacity ConfiguredClockSpeed ConfiguredVoltage Manufacturer ... 8589934592 2133 1200 Kingston ... 8589934592 2133 1200 Samsung 一般购买内存条就关心上面几个参数: 容量, 频率, 电压，生产商；其余参数由于版面有限，这里就不再展示了。
附录: 内存条参数说明 参数 描述 Capacity 获取内存容量（单位KB） Caption 物理内存还虚拟内存 ConfiguredClockSpeed 配置时钟速度 ConfiguredVoltage 配置电压 CreationClassName 创建类名 DataWidth 获取内存带宽 Description 描述 DeviceLocator 获取设备定位器 FormFactor 构成因素 HotSwappable 是否支持热插拔 InstallDate 安装日期 InterleaveDataDepth 数据交错深度 InterleavePosition 交错的位置 Manufacturer 生产商 MaxVoltage 最大电压 MemoryType 内存类型 MinVoltage 最小电压 Model 型号 Name 名字 OtherIdentifyingInfo 其他识别信息 PartNumber 零件编号 PositionInRow 行位置 PoweredOn 是否接通电源 Removable 是否可拆卸 Replaceable 是否可更换 SerialNumber 编号 SKU SKU号 SMBIOSMemoryType SMBIOS内存类型 Speed 速率 Status 状态 Tag 唯一标识符的物理存储器 TotalWidth 总宽 TypeDetail 类型详细信息 Version 版本信息</description></item><item><title>Defer, Panic and Recover</title><link>https://yuguo.im/post/2019/defer-panic-and-recover/</link><pubDate>Wed, 13 Feb 2019 12:14:17 +0800</pubDate><guid>https://yuguo.im/post/2019/defer-panic-and-recover/</guid><description>翻译自 golang 的官方博客 Defer, Panic, and Recover
Go 具有控制流程的常用机制：if，for，switch，goto。它还有 go 语句在单独的 goroutine 中运行代码。在这里，我想讨论一些不太常见的问题：defer, panic, recover。
defer 语句将函数调用推送到列表中。在周围函数返回后执行已保存调用的列表。延迟通常用于简化执行各种清理操作的功能。
举个例子，让我们看一个打开两个文件并将一个文件的内容复制到另一个文件的函数：
func CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } dst, err := os.Create(dstName) if err != nil { return } written, err = io.Copy(dst, src) dst.Close() src.Close() return } 这可以正常运行，但有一个 bug。 如果对 os.Create 的调用失败，该函数将返回而不关闭源文件。 这可以通过在第二个 return 语句之前调用 src.Close 来轻松解决，但如果函数更复杂，则问题可能不会那么容易被注意到并解决。 通过引入 defer 语句，我们可以确保文件始终关闭：</description></item><item><title>Vim Tutorial</title><link>https://yuguo.im/post/2019/vim-tutorial/</link><pubDate>Mon, 28 Jan 2019 12:02:30 +0800</pubDate><guid>https://yuguo.im/post/2019/vim-tutorial/</guid><description>从 2015 年使用 Vim 至今已经有 4 个年头了，每次都是碰到一个不会的操作现查，加上不是特别常用，于是促成了“半吊子”的诞生(/ω＼)，近几日偶然间发现 Vim 自带教程，贴出来和大家分享下。
进入终端 Terminal 执行命令 vimtutor 洋洋洒洒 30 分钟的简易教程，大家可以手动见证 关于上述内置教程的位置，大家可以通过 vimtutor --help 查看(请注意只有几秒，一闪而逝), 我的位置是 /usr/share/vim/vim74/tutor root@cloud:/usr/share/vim/vim74/tutor# ls README.el.cp737.txt tutor.de.utf-8 tutor.hr.utf-8 tutor.nb.utf-8 tutor.ru.utf-8 tutor.vim README.el.txt tutor.el tutor.hu tutor.nl tutor.sk tutor.vi.utf-8 README.txt tutor.el.cp737 tutor.hu.cp1250 tutor.nl.utf-8 tutor.sk.cp1250 tutor.zh.big5 tutor tutor.el.utf-8 tutor.hu.utf-8 tutor.no tutor.sk.utf-8 tutor.zh_cn.utf-8 tutor.bar tutor.eo tutor.it tutor.no.utf-8 tutor.sr.cp1250 tutor.zh.euc tutor.bar.utf-8 tutor.eo.utf-8 tutor.it.utf-8 tutor.pl tutor.sr.utf-8 tutor.zh_tw.utf-8 tutor.ca tutor.es tutor.ja.euc tutor.pl.cp1250 tutor.sv tutor.</description></item><item><title>Burning</title><link>https://yuguo.im/post/2019/burning/</link><pubDate>Tue, 22 Jan 2019 20:28:01 +0800</pubDate><guid>https://yuguo.im/post/2019/burning/</guid><description>Destiny - NEFFEX
# 歌词大意 Yeah I don't believe in destiny 我不相信命运 I just do what's best for me 我只做对我有利的事 Don't listen to my enemies 别听信我的敌人的话 They're just full of jealousy 他们满心妒忌 Dah, This legacy 呵 这就是他们的遗产 You gonna see what's left in me 你将看到我的成就 You gonna see success of me 你将看我通向成功 You ain't see the rest of me 你看不到我剩余的部分 I just wanna be the best at what I know 我只想成为自认为最棒的自己 Better then the rest, just watch me grow 比过去的自己更优秀 看我一步步成长吧 Put me to the test and watch me go 你设法考验我 却只能看着我离开 This is my quest, I'm ma make it known 这是我的目标 我会让它人尽皆知 They call me obsessive, oh I know 他们说我痴人说梦 这我知道 Call me selective with my notes 还说我性格挑剔 Call me aggressive with my flow 当我一路顺风的时候 他们说我好强 Call me offensive even though 说我无礼有讨人厌 So I ain't gonna lie life's tough 即使他们这么说我 妒忌我 我也不否认 生活真的很艰辛 Try to get by life's rough 试着解决这些生活中的困难 Try to do it right, it's not enough 试着做好每件事 但这些都不能满足我的野心 Even though you try, you still mess up 即使你努力的尝试 生活还是一团糟 But I'm still gonna fight for what I love 但是为了我所爱的 我甘愿奋斗不息 Still gonna die for what I love 为爱而生 为爱而死 Still gonna try out, won't give up 努力拼搏 永不言弃 Still gonna fight until I've won 除非得到我想要的 They say I'm way too obsessed 他们笑我痴 And I've got nothing left 无所作为 And I'm not quite there yet 无才无能 But those words they'll regret 但迟早他们会为此言感到后悔 Cause I've got something left 因为我正在付出行动 And I'm not giving in 我不会投降 I will not let them win 不会把胜利拱手让人 I won't stop till the end, no 不到最后不罢休 I've been through some injuries 我已承受过痛苦 Mentally and physically 肉体与精神上的痛苦 Studied them religiously 但我真诚的从中吸取教训 So I don't repeat history 为的是不让历史重演 And people won't admit to me 可人们不承认我 They don't want a victory 他们不希望我赢 Bad enough to get it, see 瞧 如此黑心的想要阻止我 They'd rather just go leave it be 可惜他们只会放弃自己的梦想 And no, this journey 可我和他们不一样 I've been on since thirteen 从13岁开始我就踏上了征程 Working hard and learning 刻苦学习 Never stopping searching 不停探索 Dah, it's burning 哈 心中燃起了信念之火 All this passion hurts me 这些激情让我有些喘不过气来 I took action, working 于是我立马采取实际行动 不断努力 Writing down these words, see 瞧 别看我上面写着这些话 No, I'm not okay 其实我过得一点都不好 I just wanna be something 我只想有所作为 I don't wanna be nothing 而不是成为窝囊废 Living all alone 即使一个人独来独往 No, I'm not alright 我却一点都不快乐 I'm just barely getting by 我只是勉强的活着罢了 But I'll tell you I'm just fine 即便如此 我还是会假惺惺的跟你说 我过得可好啦 So you leave me alone 于是你离开了我 They say I'm way too obsessed 他们说我太痴迷了 And I've got nothing left 一无所有 And I'm not quite there yet 无才无能 But those words they'll regret 但迟早他们会为此言感到后悔 Cause I've got something left 因为我已经开始有收获了 And I'm not giving in 并且我绝不会投降 I will not let them win 不会把胜利拱手让人 I won't stop till the end, no 生命不止 奋斗不息</description></item><item><title>Mysql M2B in Action with Docker</title><link>https://yuguo.im/post/2019/mysql-m2b-in-action/</link><pubDate>Fri, 11 Jan 2019 18:05:10 +0800</pubDate><guid>https://yuguo.im/post/2019/mysql-m2b-in-action/</guid><description>M2B: 主主备份(DIY, 哈哈)。最近和数据库备份杠上了，碍于手上没有足够的服务器，于是在一个服务器上使用 Docker 运行两个 Mysql 实例, 下面是主主备份的具体流程, 每一步都不能跳过，请仔细阅读。
1. 运行两个 mysql 实例: mysql-1 和 mysql-2 确保两台服务器上有相同的数据。
root@cloud:~# docker run -p 10028:3306 --name mysql-1 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 root@cloud:~# docker run -p 10029:3306 --name mysql-2 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 2. 两个实例分别修改配置文件和创建复制账号 启用二进制日志，选择唯一的服务器ID，并创建复制账号
# mysql-1 # 进入实例 mysql-1 root@cloud:~# docker exec -it mysql-1 bash # 修改配置文件 my.cnf root@343cef5a6f96:/# vim /etc/mysql/my.cnf [mysqld] server-id = 128 log_bin = mysql-bin relay-log = mysql-relay-bin # replicate-wild-do-table=scheme.</description></item><item><title>Cannot open shared object file: Permission denied</title><link>https://yuguo.im/post/2019/docker-run-mysql-error/</link><pubDate>Wed, 09 Jan 2019 20:42:10 +0800</pubDate><guid>https://yuguo.im/post/2019/docker-run-mysql-error/</guid><description>我想通过 docker 来运行 mysql 实例, 网上教程一大堆，结果以为很简单的事，搞了大半天, 记录下来，希望能帮到大家。
环境 Ubuntu 14.04 Docker 18.09 Mysql 5.7 问题 root@cloud:~# docker run --name mysql -d -e MYSQL_ROOT_PASSWORD=12345 mysql:5.7 11637add4a41b827a9691fe6e77fba13ae63319d74713c64ef2e92276df6583f root@cloud:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@cloud:~# docker logs mysql ERROR: mysqld failed while attempting to check config command was: &amp;quot;mysqld --verbose --help --log-bin-index=/tmp/tmp.m22w4ZgLhP&amp;quot; mysqld: error while loading shared libraries: libpthread.so.0: cannot open shared object file: Permission denied 解决方案 解决过程中, 尝试各种以 权限 为中心的解决办法，均无效，有的网站上把 /usr/bin 的权限放开后就可以了，但是本人尝试无效。大家也可以试试。</description></item><item><title>通过命令行激活Win10</title><link>https://yuguo.im/post/2019/cmd-activate-win10/</link><pubDate>Sun, 06 Jan 2019 17:37:01 +0800</pubDate><guid>https://yuguo.im/post/2019/cmd-activate-win10/</guid><description> 一直以来，网上各种激活工具，层出不穷，但是更多的是病毒和垃圾广告， 费心寻找之下，终于找到这种简单、免安装的方式来激活。 缺点是只有 180 天有效期。
方法 1. 通过 slmgr slmgr(Software LiscenceManager)
// 1.检查是VL版本 slmgr /dlv // 产品密钥通道: 包含VL的字符串 如果不包含则终止此方法 // 2.激活系统 slmgr /skms kms.03k.org slmgr /ato 2. 一键激活 参考这篇文章: http://kms.cangshui.net/
参考文章 https://www.jianshu.com/p/5886e8cbbaf3 https://03k.org/kms.html</description></item><item><title>Plugin Statistic</title><link>https://yuguo.im/post/2019/plugin-statistic/</link><pubDate>Sun, 06 Jan 2019 16:01:48 +0800</pubDate><guid>https://yuguo.im/post/2019/plugin-statistic/</guid><description> 统计项目中的有效代码行数和注释是一件很有趣的事, 安利大家一款统计代码行数的插件 statistic
安装 进入 File -&amp;gt; Settings -&amp;gt; Plugins 搜索关键字 statistic -&amp;gt; Search in repositories 选中插件 -&amp;gt; Install 安装成功后重启 Pycharm 使用 以 Flask 为例
底边栏 statistic Refresh Detail 表头 描述 Source File 单个文件名 Total Lines 单个文件总行数 Source code Lines 纯代码行数 Source code Lines[%] 纯代码行数百分比 Comment Lines 注释行数 Comment Lines[%] 注释行数百分比 Blank Lines 空行行数 Blank Lines[%] 空行行数百分比</description></item><item><title>Golang何时该使用指针?</title><link>https://yuguo.im/post/2018/golang-pointers/</link><pubDate>Tue, 25 Dec 2018 21:05:31 +0800</pubDate><guid>https://yuguo.im/post/2018/golang-pointers/</guid><description>Github 原文
一个函数何时该用指针类型做receiver对初学者而言一直是个头疼的问题。如果不知道该如何取舍，选择指针类型的receiver。但有些时候value receiver更加合适，比如对象是一些轻量级的不变的structs，使用value receiver会更加高效。下面是列举了一些常用的判断指导。
如果receiver是map、func或者chan，不要使用指针 如果receiver是slice并且该函数并不会修改此slice，不要使用指针 如果该函数会修改receiver，此时一定要用指针 如果receiver是struct并且包含互斥类型sync.Mutex，或者是类似的同步变量，receiver必须是指针，这样可以避免对象拷贝 如果receiver是较大的struct或者array，使用指针则更加高效。多大才算大？假设struct内所有成员都要作为函数变量传进去，如果觉得这时数据太多，就是struct太大 如果receiver是struct，array或者slice，并且其中某个element指向了某个可变量，则这个时候receiver选指针会使代码的意图更加明显 如果receiver使较小的struct或者array，并且其变量都是些不变量、常量，例如time.Time，value receiver更加适合，因为value receiver可以减少需要回收的垃圾量 最后，如果不确定用哪个，使用指针类的receiver</description></item><item><title>Markdown中实现合并单元格</title><link>https://yuguo.im/post/2018/markdown-merge-cells/</link><pubDate>Mon, 10 Dec 2018 21:30:28 +0800</pubDate><guid>https://yuguo.im/post/2018/markdown-merge-cells/</guid><description>Method 使用 &amp;lt;br&amp;gt; 换行符(隐性换行) 使用 html 标签 rowspan 和 colspan excel 转 html Raw &amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th rowspan=&amp;quot;2&amp;quot;&amp;gt;值班人员&amp;lt;/th&amp;gt; &amp;lt;th colspan=&amp;quot;2&amp;quot;&amp;gt;星期一&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;星期二&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;李强&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;张明&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;王平&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; Preview</description></item><item><title>wkhtmltopdf 中文显示有误, 显示“口”方框的解决方案</title><link>https://yuguo.im/post/2018/wkhtmltopdf-zh-display-error/</link><pubDate>Mon, 15 Oct 2018 17:54:24 +0000</pubDate><guid>https://yuguo.im/post/2018/wkhtmltopdf-zh-display-error/</guid><description>运行环境 Ubuntu 14.04.2 LTS wkhtmltopdf 0.9.9 test.html 测试文件的编码为 UTF-8，文件内部标记编码也是UTF-8，如下所示： &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt; 执行过程 $ wkhtmltopdf test.html test.pdf Loading page (1/2) Printing pages (2/2) Done 检查转化后的 pdf 文件，中文显示有问题
解决方案 在 Windows 目录( C:\WINDOWS\Fonts\ )中找到文件 simsun.ttc 大概 17M 左右 拷贝至 /usr/share/fonts/chinese/TrueType/simsun.ttc，如果目录 chinese/TrueType 不存在，则手动创建 加载缓存 fc-cache -fv 再次执行 wkhtmltopdf test.html test.pdf 检查显示，完美。 有些博客中会建议拷贝 *.ttf 之类的文件，目前我没有亲测通过，暂不加入此。</description></item><item><title>阿里云ECS无法访问</title><link>https://yuguo.im/post/2018/05/aliyun-ecs-connect-error/</link><pubDate>Wed, 23 May 2018 21:32:30 +0800</pubDate><guid>https://yuguo.im/post/2018/05/aliyun-ecs-connect-error/</guid><description>今天有一朋友让我帮忙看下他的云服务器，他说服务器无法远程访问，即使重启了也不行。说来挺惭愧，我也搞了半天没查出来问题在哪！于是我帮他申请工单，没想到阿里云工程师反馈很快，给了他最大权限，三下五除二，问题被解决了。
工程师 XXXXX 号: 因为您服务器的网络是专有网络，专有网络服务器的 公网ip 是通过 nat 映射到 内网网卡的，所以您服务器内是无法直接监听 公网ip 的。还请您知晓，谢谢 服务器sshd服务无法启动，报错: error: Bind to port 22 on 101.132.36.203 failed: Cannot assign requested address. fatal: Cannot bind any address. 其实他说的这个原因，我也查到了，但是我误解了assign的意思。assign 此处的含义是“指定”, 而不是“分配”。
解决方案: 编辑 /etc/ssh/sshd_config 注释 #ListenAddress 101.132.36.203</description></item><item><title>Clean Up Disk Space on Win10</title><link>https://yuguo.im/post/2018/05/clean-up-disk-space-on-win10/</link><pubDate>Tue, 22 May 2018 21:23:13 +0800</pubDate><guid>https://yuguo.im/post/2018/05/clean-up-disk-space-on-win10/</guid><description>今天win10一不小心被升级了，多出一个文件夹Windows.old 将近20G把磁盘空间快占满了，寻了下资料，怎么合理删除这个文件夹？
步骤 Win+S 输入disk 选择存储设置 选择立即释放空间 选中需要好删除的文件 需要清理系统磁盘的童鞋可以试试。</description></item><item><title>Pip Install Pipenv Fail</title><link>https://yuguo.im/post/2018/05/pip-install-pipenv-fail/</link><pubDate>Mon, 21 May 2018 21:15:15 +0800</pubDate><guid>https://yuguo.im/post/2018/05/pip-install-pipenv-fail/</guid><description> 提示: &amp;lsquo;install_requires&amp;rsquo; must be a string or list of strings containing valid project/version requirement specifiers
解决方式(pipenv版本管理)
思路: 先装次新版本，再装最新版本
pip install pipenv==11.10.4 pip install pipenv</description></item><item><title>Invisible Postman</title><link>https://yuguo.im/post/2018/05/invisible-postman/</link><pubDate>Sat, 05 May 2018 21:00:00 +0800</pubDate><guid>https://yuguo.im/post/2018/05/invisible-postman/</guid><description> 软件Postman跑到屏幕外拉不回来怎么办？
环境 Thinkpad T460P Win10 外接一个显示屏 解决方案 按 Alt + Tab 键，确保该窗口处于激活位置 再按 Alt + Space 键，激活控制菜单 按 M 键，上下左右操作，将窗口移到中央位置</description></item><item><title>VSCode配置Cmder作为默认的终端(Shell)</title><link>https://yuguo.im/post/2018/05/vscode-cmder-win10/</link><pubDate>Fri, 04 May 2018 19:09:05 +0800</pubDate><guid>https://yuguo.im/post/2018/05/vscode-cmder-win10/</guid><description>Windows系统中的默认终端不好用，于是使用了Cmder。与此同时, VSCode中的默认终端也不招人喜欢，我要Cmder移植到VSCode中怎么做呢？
环境 Cmder 安装目录 C:\Software\cmder Win10 配置 第一步: 准备启动脚本 cmder安装目录下新建文件vscmd.bat
使用VSCode打开vscmd.bat，写入下面代码
@echo off &amp;quot;C:\Software\cmder\vendor\init.bat&amp;quot; 第二步: VSCode中配置启动项和参数 VSCode找到用户设置(使用快捷键Ctrl+,) 打开settings.json 添加下面配置
{ &amp;quot;terminal.integrated.shell.windows&amp;quot;: &amp;quot;cmd.exe&amp;quot;, &amp;quot;terminal.integrated.shellArgs.windows&amp;quot;: [ &amp;quot;/K&amp;quot;, &amp;quot;C:/Software/cmder/vscmd.bat&amp;quot; ], } 第三步: 重新启动，检验成果 关闭VSCode，再重新打开，使用 Ctrl + 反引号(`) ，见证奇迹的时刻。</description></item><item><title>How To Install Docker On Win10</title><link>https://yuguo.im/post/2017/docker-for-win10/</link><pubDate>Fri, 09 Jun 2017 15:26:46 +0000</pubDate><guid>https://yuguo.im/post/2017/docker-for-win10/</guid><description>PC: Thinkpad T460p
docker-client docker-toolbox</description></item><item><title>高铁座位为什么没有E?</title><link>https://yuguo.im/post/2017/high-speed-seat/</link><pubDate>Wed, 03 May 2017 17:03:14 +0000</pubDate><guid>https://yuguo.im/post/2017/high-speed-seat/</guid><description>&lt;blockquote>
&lt;p>以前一直没有注意过这个问题,直至今天乘坐G1932次列车从上海虹桥开往西安北站.我所选的是1号车厢8F座位,我看了下周围的座次,只有AC, DF后缀结尾的座次;于是上百度上搜索了一下,找到了答案&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>MySQL的limit用法和分页查询的性能优化</title><link>https://yuguo.im/post/2017/mysql-limit/</link><pubDate>Thu, 27 Apr 2017 15:16:27 +0000</pubDate><guid>https://yuguo.im/post/2017/mysql-limit/</guid><description>学习任何东西都可以按照3W的框架进行，容器技术也是一样，先回答 What、Why 和 How 这三个问题。
CloudMan-每天5分钟玩转容器技术（6）
我非常赞同CloudMan的观点, 下面咱就以这三个问题来讨论今天的主题
What-Mysql中的LIMIT是干啥的? 在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。
SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。如果给定一个参数(rows), 偏移量offset默认为0, 指定返回[:rows]的数据; 如果给定两个参数(offset, rows)，offset指定第一个返回记录行的偏移量，rows指定返回记录行的最大数目。
mysql&amp;gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 获得开头的几行数据
mysql&amp;gt; SELECT * FROM table LIMIT 10; // 检索记录行 0-9 获得结尾的几行数据
mysql&amp;gt; SELECT * FROM table LIMIT 100,-1; // 检索记录行 100-last. Why-为什么需要为分页查询做优化? 随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似下面示例。总而言之，越往后分页，LIMIT语句的偏移量(offset)就会越大，速度也会明显变 随着业务的复杂度越来越高, 查询条件不断增多, 可想而知, 速度也会越来越慢 SELECT * FROM users WHERE age = 12 ORDER BY id LIMIT 10000, 20 How-分页查询如何优化?</description></item><item><title>configparser(PY3) VS ConfigParser(PY2)</title><link>https://yuguo.im/post/2017/python-config/</link><pubDate>Wed, 26 Apr 2017 18:25:23 +0000</pubDate><guid>https://yuguo.im/post/2017/python-config/</guid><description>&lt;blockquote>
&lt;p>关于使用ConfigParser,我的小伙伴想实现特殊的需求: 1.配置中的参数均大写; 2.配置文件中&amp;quot;=&amp;ldquo;等号两侧无空格, 于是摸索中写下这篇文章, 方便有缘人&lt;/p>
&lt;/blockquote></description></item><item><title>WSGI，uwsgi和uWSGI的区别</title><link>https://yuguo.im/post/2017/wsgi-uwsgi/</link><pubDate>Tue, 25 Apr 2017 16:00:13 +0000</pubDate><guid>https://yuguo.im/post/2017/wsgi-uwsgi/</guid><description>WSGI Web服务器网关接口
WSGI(Python Web Server Gateway Interface, Web服务器网关接口)是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口
uwsgi uwsgi协议
uwsgi同WSGI一样是一种通信协议。uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。
uWSGI uWSGI
uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。
最流行的 uWSGI 服务器是 uwsgi</description></item><item><title>HTTPS for GitHub Pages</title><link>https://yuguo.im/post/2017/github-pages-https/</link><pubDate>Tue, 25 Apr 2017 09:59:37 +0000</pubDate><guid>https://yuguo.im/post/2017/github-pages-https/</guid><description>&lt;blockquote>
&lt;p>福利来啦, Github响应小伙伴们的号召, 于2016年6月15日, 推出https服务, 为username.github.io站点添加&lt;code>Enforce HTTPS&lt;/code>选项, 详情请参阅&lt;a href="https://github.com/blog/2186-https-for-github-pages">https://github.com/blog/2186-https-for-github-pages&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Python 中的 exit()、sys.exit() 和 os._exit()的区别</title><link>https://yuguo.im/post/2017/python-exit/</link><pubDate>Mon, 24 Apr 2017 11:21:54 +0000</pubDate><guid>https://yuguo.im/post/2017/python-exit/</guid><description>Python官方解释 exit() exit
Objects that when printed, print a message like “Use quit() or Ctrl-D (i.e. EOF) to exit”, and when called, raise SystemExit with the specified exit code.
简言之: 抛出 SystemExit 异常. 用于给交互式Shell退出.
sys.exit() sys.exit
Exit from Python. This is implemented by raising the SystemExit exception, so cleanup actions specified by finally clauses of try statements are honored, and it is possible to intercept the exit attempt at an outer level.</description></item><item><title>Docker学习笔记</title><link>https://yuguo.im/post/2017/docker-note/</link><pubDate>Sun, 23 Apr 2017 23:17:56 +0000</pubDate><guid>https://yuguo.im/post/2017/docker-note/</guid><description>Docker简介 What is Docker Docker is the world’s leading software container platform. Developers use Docker to eliminate “works on my machine” problems when collaborating on code with co-workers. Operators use Docker to run and manage apps side-by-side in isolated containers to get better compute density. Enterprises use Docker to build agile software delivery pipelines to ship new features faster, more securely and with confidence for both Linux and Windows Server apps.</description></item><item><title>Go学习笔记</title><link>https://yuguo.im/post/2017/go-note/</link><pubDate>Sat, 22 Apr 2017 22:53:29 +0000</pubDate><guid>https://yuguo.im/post/2017/go-note/</guid><description>&lt;h1 id="go笔记">Go笔记&lt;/h1>
&lt;p>{% blockquote Go &lt;a href="https://golang.org">https://golang.org&lt;/a> Welcome to golang.org %}
The Go programming language is an open source project to make programmers more productive.
{% endblockquote %}&lt;/p>
&lt;blockquote>
&lt;p>Go编程语言是一个开源项目，使程序员更有成效&lt;/p>
&lt;/blockquote></description></item><item><title>关于Python中json库的一些整理</title><link>https://yuguo.im/post/2017/python-json/</link><pubDate>Wed, 19 Apr 2017 15:42:53 +0000</pubDate><guid>https://yuguo.im/post/2017/python-json/</guid><description>&lt;h3 id="jsondump和jsondumps的区别来自stackoverflow的释疑httpstackoverflowcomquestions36059194what-is-the-difference-between-json-dump-and-json-dumps-in-python">json.dump和json.dumps的区别(&lt;a href="http://stackoverflow.com/questions/36059194/what-is-the-difference-between-json-dump-and-json-dumps-in-python">来自Stackoverflow的释疑&lt;/a>)&lt;/h3>
&lt;ul>
&lt;li>json.dump&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Serialize &lt;code>obj&lt;/code> as a JSON formatted stream to &lt;code>fp&lt;/code> (a &lt;code>.write()&lt;/code>-supporting file-like object).
If &lt;code>ensure_ascii&lt;/code> is &lt;code>False&lt;/code>, some chunks written to &lt;code>fp&lt;/code> may be &lt;code>unicode&lt;/code> instances.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>json.dumps&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Serialize &lt;code>obj&lt;/code> to a JSON formatted &lt;code>str&lt;/code>.
If &lt;code>ensure_ascii&lt;/code> is &lt;code>False&lt;/code>, all non-ASCII characters are not escaped, and the return value may be a &lt;code>unicode&lt;/code> instance.&lt;/p>
&lt;/blockquote></description></item><item><title>Pycharm实现前进/后退</title><link>https://yuguo.im/post/2017/pycharm-jump/</link><pubDate>Wed, 19 Apr 2017 14:37:44 +0000</pubDate><guid>https://yuguo.im/post/2017/pycharm-jump/</guid><description>&lt;blockquote>
&lt;p>操作系统: Ubuntu14.04; Pycharm版本: 2016.3; 这里的前进指的是追踪函数源码, 后退是前进的反方向。&lt;/p>
&lt;/blockquote></description></item><item><title>玩的就是“心跳”</title><link>https://yuguo.im/post/2017/heartbeat/</link><pubDate>Tue, 18 Apr 2017 09:49:26 +0000</pubDate><guid>https://yuguo.im/post/2017/heartbeat/</guid><description>&lt;h3 id="心跳检测是什么">心跳检测是什么？&lt;/h3>
&lt;p>这里的“心跳”，可不是男女之间心动啥的“砰砰砰”。&lt;/p>
&lt;ul>
&lt;li>心跳检测是判断对方(设备，进程或其它网元)是否正常进行，一般采用定时发送简单的通讯包，如果长时间未收到对方响应，则判断对方已经挂掉。&lt;/li>
&lt;li>&lt;a href="http://www.baike.com/wiki/%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6">心跳机制&lt;/a>是服务端和客户端检测对方是否在线的一种方式。&lt;/li>
&lt;li>心跳包就是客户端定时发送简单的信息给服务端告诉它我还在，服务端视情况而定给客户单返回合适信息，一般情况下是客户端给服务端发心跳包。&lt;/li>
&lt;/ul></description></item><item><title>由罗技G502鼠标引起的“聒噪”</title><link>https://yuguo.im/post/2017/pnvssn/</link><pubDate>Sat, 15 Apr 2017 11:52:28 +0000</pubDate><guid>https://yuguo.im/post/2017/pnvssn/</guid><description>&lt;blockquote>
&lt;p>昨晚在京东商城上买了一个罗技鼠标，今天上午到货，于是寻思着吧，找下序列号，查下它是不是正品。按照网友的提示，我在包装盒上翻来覆去，就是找不到可以刮的地方，看到&lt;code>P/N&lt;/code>,&lt;code>S/N&lt;/code>,这都是啥？？？&lt;/p>
&lt;/blockquote></description></item><item><title>Pycharm配置autopep8到菜单</title><link>https://yuguo.im/post/2017/pycharm-autopep8/</link><pubDate>Wed, 12 Apr 2017 22:27:15 +0000</pubDate><guid>https://yuguo.im/post/2017/pycharm-autopep8/</guid><description>&lt;p>{% note success %}
Pycharm可以自动检测PEP8规范, 菜单&lt;code>Code&lt;/code>–&amp;gt;&lt;code>Reformat Code&lt;/code>可以自动调整代码,但是效果一般,只能实现简单的规范代码; 为了满足需要, 可以安装autopep8来自动修改文件实现PEP8规范.
{% endnote %}&lt;/p></description></item><item><title>Python中字符串格式化符号和转义字符含义</title><link>https://yuguo.im/post/2017/python-format/</link><pubDate>Wed, 12 Apr 2017 15:36:26 +0000</pubDate><guid>https://yuguo.im/post/2017/python-format/</guid><description>&lt;blockquote>
&lt;p>这篇文档整理自&lt;a href="http://bbs.fishc.com/forum.php?mod=viewthread&amp;amp;tid=39140&amp;amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D403">鱼C论坛&lt;/a>, 感谢作者输出,我只是一枚搬运工&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>第三方登录</title><link>https://yuguo.im/post/2017/oauth2/</link><pubDate>Tue, 11 Apr 2017 23:22:44 +0000</pubDate><guid>https://yuguo.im/post/2017/oauth2/</guid><description>&lt;blockquote>
&lt;p>这篇文档的源自一个第三方登录的需求,于是我就想搞清楚怎么实现第三方登录的,网上有现成的解决方案: &lt;a href="http://dev.umeng.com/social/android/login-page">友盟&lt;/a>和&lt;a href="http://wiki.mob.com/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/">ShareSDK&lt;/a>;但是这不是我最需要,于是就有了下面的的记录:&lt;/p>
&lt;/blockquote></description></item><item><title>Python和Excel的不解之缘</title><link>https://yuguo.im/post/2017/python-excel/</link><pubDate>Mon, 10 Apr 2017 18:48:49 +0000</pubDate><guid>https://yuguo.im/post/2017/python-excel/</guid><description>&lt;h2 id="表格处理模块">表格处理模块&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://xlwt.readthedocs.io/en/latest/">xlwt (writing xls files)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://xlrd.readthedocs.io/en/latest/">xlrd (reading xls/xlsx files)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openpyxl.readthedocs.io/en/default/">openpyxl (reading/writing xlsx files)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xlsxwriter.readthedocs.io">xlsxwriter (writing xlsx files)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.python-excel.org/">more details&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>mysql</title><link>https://yuguo.im/post/2017/mysql/</link><pubDate>Fri, 31 Mar 2017 23:36:41 +0000</pubDate><guid>https://yuguo.im/post/2017/mysql/</guid><description>&lt;h2 id="初涉mysql">初涉Mysql&lt;/h2>
&lt;h3 id="mysql概述">MySQL概述&lt;/h3>
&lt;ul>
&lt;li>MySQL由瑞典MySQL AB公司开发，目前属于Oracle公司.&lt;/li>
&lt;li>MySQL是一个开源的关系型数据库管理系统.&lt;/li>
&lt;li>MySQL分为社区版和企业版.&lt;/li>
&lt;/ul></description></item><item><title>Python3正则表达式特殊符号及用法(详细列表)</title><link>https://yuguo.im/post/2015/regex/</link><pubDate>Sat, 26 Sep 2015 08:45:41 +0000</pubDate><guid>https://yuguo.im/post/2015/regex/</guid><description>这篇文档整理自鱼C论坛, 感谢作者输出,我只是一枚搬运工&amp;hellip;
正则表达式的强大之处在于特殊符号的应用,特殊符号定义了字符集合、子组匹配、模式重复次数。正是这些特性符号使得一个正则表达式可以匹配字符串集合而不只是一个字符串。
注1: 为了便于理解，难点的地方均用斜体举了栗子。
字符 含义 . 表示匹配除了换行符外的任何字符 注: 通过设置re.DOTALL标志可以使.匹配任何字符(包括换行符) ¦(竖杠) A¦(竖杠)B,表示匹配正则表达式A或者B ^ 1.(脱字符)匹配输入字符串的开始位置 2.如果设置了re.MULTILINE标志,^也匹配换行符之后的位置 $ 1.匹配输入字符串的结束位置2.如果设置了re.MULTILINE标志,$也匹配换行符之前的位置 \ 1.将一个普通字符变成特殊字符，例如 \d 表示匹配所有十进制数字2. 解除元字符的特殊功能，例如 \. 表示匹配点号本身3. 引用序号对应的子组所匹配的字符串4. 详见下方列举 [&amp;hellip;] 字符类，匹配所包含的任意一个字符注1：连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符注2：特殊字符仅有反斜线 \ 保持特殊含义，用于转义字符。其它特殊字符如 *、+、? 等均作为普通字符匹配 注3：脱字符 ^ 如果出现在首位则表示匹配不包含其中的任意字符；如果 ^ 出现在字符串中间就仅作为普通字符匹配 {M,N} M 和 N 均为非负整数，其中 M &amp;lt;= N，表示前边的 RE 匹配 M ~ N 次注1：{M,} 表示至少匹配 M 次注2：{,N} 等价于 {0,N}注3：{N} 表示需要匹配 N 次 * 匹配前面的子表达式零次或多次，等价于 {0,} + 匹配前面的子表达式一次或多次，等价于 {1,} ?</description></item><item><title>Vim Cheat Sheet</title><link>https://yuguo.im/post/2015/vim/</link><pubDate>Mon, 21 Sep 2015 16:55:54 +0000</pubDate><guid>https://yuguo.im/post/2015/vim/</guid><description>光标 h - 左移光标 j - 下移光标 k - 上移光标 l - 右移光标 w - 移动到下个单词开头 W - 移动到下个单词开头(单词含标点) e - 移动到下个单词结尾 E - 移动到下个单词结尾(单词含标点) b - 移动到上个单词结尾 B - 移动到上个单词结尾(单词含标点) 0 - 移动到行首 ^ - 移动到行首的非空白符 $ - 移动到行尾 G - 移动到文档末行行首 5G - 移动到第五行 Tip1 : 命令前追加数字表示命令的重复次数, 比如4j 表示向下移动四行
插入模式 - 插入/追加文本 i - 从光标前开始插入字符 I - 从行首开始插入字符 a - 从光标后开始插入字符 A - 从行尾开始插入字符 o - 在当前行之下另起一行, 开始插入字符 O - 在当前行之上另起一行, 开始插入字符 ea - 从当前单词末尾开始插入 Esc - 退出插入模式 编辑 r - 替换当前字符 J - 将下一行合并到当前行 cc - 清空当前行, 然后进入插入模式 cw - 从光标位置开始, 修改单词 c$ - 从光标位置开始, 修改当前行 s - 删除当前字符, 然后进入插入模式 S - 清空当前行, 然后进入插入模式 (同cc) xp - 当前字符后移 u - 撤销 Ctrl + r - 重复 .</description></item></channel></rss>