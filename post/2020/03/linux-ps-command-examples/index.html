<!doctype html><html>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<title> 14 个重要的 Linux ps 命令实战 &#183; 随笔 </title>
<link rel=stylesheet href=https://yuguo.im/css/slim.css>
<link rel=stylesheet href=https://yuguo.im/css/highlight.min.css>
<link rel=stylesheet href=https://yuguo.im/css/sspfont.css>
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel=stylesheet type=text/css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/favicon.ico>
<link href rel=alternate type=application/rss+xml title=随笔>
</head>
<body>
<div class=container>
<div class=header>
<h1 class=site-title><a href=https://yuguo.im/>随笔</a></h1>
<p class=site-tagline>Stay hungry. Stay foolish.</p>
<div class=nav>
<a class=nav-btn href=#>
<span class="ci ci-burger"></span>
</a>
<ul class=nav-list>
<li class=spacer>&ac;</li>
<li><a href=https://github.com/xiayuguo>Github</a></li>
<li><a href=https://twitter.com/yuguo_im>Twitter</a></li>
<li><a href=/index.xml>RSS</a>
</ul>
</div>
</div>
<div class=content>
<div class=posts>
<div class=post>
<h2 class=post-title><a href=https://yuguo.im/post/2020/03/linux-ps-command-examples/>14 个重要的 Linux ps 命令实战</a></h2>
<span class=post-date>Mar 24, 2020 </span>
<div class=post-content>
<blockquote>
<p>作者：Pungki Arianto</p>
<p>原文网址：https://linoxide.com/how-tos/linux-ps-command-examples/</p>
</blockquote>
<p>Linux ps 命令是用于捕获系统上当前进程的内置工具。它将一次捕获系统状况。如果您想实时进行刷新，可以使用 top 命令。</p>
<p>在本教程中，我将向您展示 ps 命令的常见实际示例，该示例有助于您的日常linux系统管理。</p>
<h2 id=1-不带任何选项运行-ps>1. 不带任何选项运行 ps</h2>
<p>这是非常基本的 ps 用法。只需在控制台上键入 ps 即可查看其结果。</p>
<pre tabindex=0><code>root@ParkW:~# ps
  PID TTY          TIME CMD
28269 pts/1    00:00:00 bash
28307 pts/1    00:00:00 ps
</code></pre><p>默认情况下，它将向我们显示 4 列信息。</p>
<ul>
<li>PID 是运行命令（CMD）的进程 ID</li>
<li>TTY 是运行命令的地方</li>
<li>TIME 是运行命令时 CPU 使用了多少时间</li>
<li>CMD 是进程运行的命令</li>
</ul>
<p>这里的信息展示是<strong>无序</strong>的。</p>
<h2 id=2-显示当前所有进程>2. 显示当前所有进程</h2>
<p>为此，我们可以使用 <code>-a</code> 选项。我们可以猜到, <code>-a</code> 是 <code>all</code> 的简写。选项 <code>x</code> 将显示所有进程，即使当前进程也未与任何TTY（终端）相关联</p>
<pre tabindex=0><code>$ ps -ax
</code></pre><p>该结果可能会比较多。为了使其更易于阅读，请将其与 <code>less</code> 命令结合使用。</p>
<pre tabindex=0><code>$ ps -ax | less
</code></pre><pre tabindex=0><code>  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:12 /sbin/init
    2 ?        S      0:00 [kthreadd]
    3 ?        S      1:02 [ksoftirqd/0]
    5 ?        S&lt;     0:00 [kworker/0:0H]
    7 ?        S     28:50 [rcu_preempt]
    8 ?        S      0:00 [rcu_sched]
    9 ?        S      0:00 [rcu_bh]
   10 ?        S      0:04 [migration/0]
   11 ?        S      0:04 [migration/1]
   12 ?        S      0:09 [ksoftirqd/1]
   14 ?        S&lt;     0:00 [kworker/1:0H]
   15 ?        S      0:04 [migration/2]
   16 ?        S      0:09 [ksoftirqd/2]
   18 ?        S&lt;     0:00 [kworker/2:0H]
   19 ?        S      0:04 [migration/3]
   20 ?        S      0:09 [ksoftirqd/3]
:
</code></pre><h2 id=3-按用户过滤进程>3. 按用户过滤进程</h2>
<p>在某些情况下，我们可能希望按用户筛选进程。为此，我们可以使用 <code>-u</code> 选项。假设我们要查看用户 <code>root</code> 运行哪些进程。所以命令如下：</p>
<pre tabindex=0><code>$ ps -u root
</code></pre><pre tabindex=0><code>root@ParkW:~# ps -u root
  PID TTY          TIME CMD
    1 ?        00:00:12 init
    2 ?        00:00:00 kthreadd
    3 ?        00:01:02 ksoftirqd/0
    5 ?        00:00:00 kworker/0:0H
    7 ?        00:28:50 rcu_preempt
</code></pre><h2 id=4-按-cpu-或内存使用情况过滤进程>4. 按 CPU 或内存使用情况过滤进程</h2>
<p>您可能希望看到的另一件事是按 CPU 或内存使用情况过滤结果。这样，您可以获取哪些进程消耗了资源的信息。为此，我们可以使用 <code>aux</code> 选项。这是一个例子：</p>
<pre tabindex=0><code>$ ps -aux | less
</code></pre><pre tabindex=0><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1   3264  2460 ?        Ss    3月12   0:12 /sbin/init
root         2  0.0  0.0      0     0 ?        S     3月12   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S     3月12   1:02 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S&lt;    3月12   0:00 [kworker/0:0H]
root         7  0.1  0.0      0     0 ?        S     3月12  28:51 [rcu_preempt]
root         8  0.0  0.0      0     0 ?        S     3月12   0:00 [rcu_sched]
root         9  0.0  0.0      0     0 ?        S     3月12   0:00 [rcu_bh]
root        10  0.0  0.0      0     0 ?        S     3月12   0:04 [migration/0]
root        11  0.0  0.0      0     0 ?        S     3月12   0:04 [migration/1]
root        12  0.0  0.0      0     0 ?        S     3月12   0:09 [ksoftirqd/1]

</code></pre><p>显示所有信息</p>
<p>由于结果可以在很长的列表中，因此我们可以将pipe较少的命令转换为ps命令。解释结果中的每个术语。</p>
<ol>
<li><code>USER - Username</code> ：与进程关联的用户名。</li>
<li><code>PID - Process ID</code> ：分配给进程的唯一数字标识符。</li>
<li><code>%CPU - Percentage of CPU</code> ：CPU 使用时间的百分比（CPU 总时间除以进程已运行的时间长度）。</li>
<li><code>%MEM - Percentage of RAM Memory</code> 内存使用百分比（已用内存除以可用总内存）。</li>
<li><code>VSZ - Virtual Memory Size</code> ：虚拟内存中进程的大小, 以 KiB 表示。</li>
<li><code>RSS - Resident Set Size</code>。</li>
<li><code>TTY - Terminal controlling the process</code>。</li>
<li><code>STAT - Process State - Possible values</code>。
<ul>
<li>R - Running。</li>
<li>S - Sleeping（可能会中断）。</li>
<li>D - Sleeping（可能不会被打断）- 用于表示进程正在处理输入/输出。</li>
<li>T - Stopped or being traced。</li>
<li>Z - Zombie or &ldquo;hung&rdquo; process. - 僵尸或“挂起”进程。</li>
</ul>
</li>
<li><code>START</code> ：进程开始的日期或时间。</li>
<li><code>TIME</code> ：该进程以及该进程启动的子进程使用累积的CPU时间。</li>
<li><code>COMMAND</code> ：启动进程的命令。</li>
</ol>
<p>默认情况下，结果是无序的。如果要按特定列排序，可以将 <code>--sort</code> 选项添加到 ps 命令中。</p>
<p>按最高 <code>CPU utilization</code> 升序排列</p>
<pre tabindex=0><code>$ ps -aux --sort -pcpu | less
</code></pre><pre tabindex=0><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1116  2.3  0.8  31916 18036 ?        S     3月12 410:07 /usr/bin/python /usr/local/bin/xxx_serviceA
root     14106  1.4  2.2 199660 45748 ?        Sl    3月23  15:16 /usr/bin/python /usr/local/bin/xxx_serviceB
mongodb   5844  0.7  1.9 236996 39820 ?        Ssl   3月16  82:20 /usr/bin/mongod --config /etc/mongodb.conf
mysql      721  0.4  3.9 349636 82448 ?        Ssl   3月12  70:29 /usr/sbin/mysqld
root     14095  0.4  2.6  74296 55280 ?        S     3月23   4:43 /usr/bin/python /usr/local/bin/xxx_serviceC
redis      787  0.3  0.1  26836  2332 ?        Ssl   3月12  66:04 /usr/bin/redis-server 0.0.0.0:6379
</code></pre><p>按最高 <code>Memory utilization</code> 升序排序</p>
<pre tabindex=0><code>$ ps -aux --sort -pmem | less
</code></pre><pre tabindex=0><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       930  0.2 21.2 1213260 437348 ?      Sl    3月12  40:13 /root/xxx/javaService start
mysql      721  0.4  3.9 349636 82448 ?        Ssl   3月12  70:31 /usr/sbin/mysqld
root     14099  0.0  3.1 116364 64776 ?        S     3月23   0:46 /usr/bin/python /usr/local/bin/xxx_Service
root     14095  0.4  2.6  74296 55280 ?        S     3月23   4:44 /usr/bin/python /usr/local/bin/xxx_ServiceB
</code></pre><p>或者我们可以将其组合为一个命令，并仅显示结果的前十位：</p>
<pre tabindex=0><code>$ ps -aux --sort -pcpu,+pmem | head -n 10
</code></pre><h2 id=5-前十大内存消耗的进程>5. 前十大内存消耗的进程</h2>
<p>这显示了系统上运行的前 10 个内存消耗进程。查看哪些进程最消耗内存是很有用的。</p>
<pre tabindex=0><code>Options:
--sort spec specifies sorting order. Sorting syntax is [+|-]key[,[+|-]key[,...]]. Choose a multi-letter key from the STANDARD FORMAT SPECIFIERS section. The &quot;+&quot; is optional since default direction is increasing numerical or lexicographic order. Identical to k. For example: ps jax --sort=uid,-ppid,+pid
</code></pre><pre tabindex=0><code># ps -auxf | sort -nr -k 4 | head -10
root 3025 3.2 13.0 1600004 245276 ? Sl 10:00 2:01 \_ /usr/bin/gnome-shell
root 2261 0.5 1.8 188108 34540 tty1 Rs+ 09:49 0:25 \_ /usr/bin/Xorg :0 -background none -verbose -auth /run/gdm/auth-for-gdm-fTksZM/database -seat seat0 -nolisten tcp vt1
root 3089 0.0 1.2 1060728 22608 ? Sl 10:00 0:00 /usr/bin/nautilus --no-default-window
root 2957 0.0 1.2 998384 23244 ? Sl 10:00 0:00 \_ /usr/libexec/gnome-settings-daemon
root 3482 0.0 1.0 632688 19344 ? Rl 10:07 0:02 /usr/libexec/gnome-terminal-server
root 3181 0.1 1.0 349960 20280 ? S 10:00 0:07 /usr/bin/vmtoolsd -n vmusr
root 802 0.0 0.9 550008 18036 ? Ssl 09:49 0:01 /usr/bin/python -Es /usr/sbin/tuned -l -P
root 950 0.0 0.8 102312 15580 ? S 09:49 0:00 \_ /sbin/dhclient -d -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient-eno16777736.pid -lf /var/lib/NetworkManager/dhclient-42456ebc-a752-4950-9adf-1b8bc29f43eb-eno16777736.lease -cf /var/lib/NetworkManager/dhclient-eno16777736.conf eno16777736
root 3154 0.0 0.8 898940 15300 ? Sl 10:00 0:00 /usr/libexec/evolution-calendar-factory
root 3020 0.0 0.8 551480 16420 ? Sl 10:00 0:00 /usr/libexec/goa-daemon
</code></pre><p><img src=http://oss.yuguo.im/blog/202003/ps-memory.webp alt></p>
<h2 id=6-按名称或进程id过滤进程>6. 按名称或进程ID过滤进程</h2>
<p>为此，我们可以使用 <code>-C</code> 选项, 关键字放在它后面。假设我们要显示名为 getty 的进程。我们可以输入：</p>
<pre tabindex=0><code>$ ps -C getty
</code></pre><pre tabindex=0><code>root@ParkW:~# ps -C getty
  PID TTY          TIME CMD
  628 ttySAC0  00:00:00 getty
</code></pre><p>如果要显示有关结果的更多详细信息，可以添加 <code>-f</code> 选项, 以在完整格式列表中显示它。上面的命令如下所示：</p>
<pre tabindex=0><code>$ ps -f -C getty
</code></pre><pre tabindex=0><code>root@ParkW:~# ps -f -C getty
UID        PID  PPID  C STIME TTY          TIME CMD
root       628     1  0  3月12 ttySAC0 00:00:00 /sbin/getty 115200 ttySAC0
</code></pre><h2 id=7-通过进程的线程过滤进程>7. 通过进程的线程过滤进程</h2>
<p>如果我们需要了解特定进程的线程，可以使用 <code>-L</code>选项, 其后跟进程 ID（PID）。这是一个实际的例子：</p>
<pre tabindex=0><code>$ ps -L 1213
</code></pre><p>可以看到，PID保持相同的值，但是显示线程数的LWP显示不同的值。</p>
<h2 id=8-显示特定进程-id-的所有线程>8. 显示特定进程 ID 的所有线程</h2>
<p>这将显示特定进程pid的所有线程。</p>
<pre tabindex=0><code>Options:
-L show threads possibly with LWP and NLWP columns.

# ps -Lf -p 3482
UID PID PPID LWP C NLWP STIME TTY TIME CMD
root 3482 1 3482 0 4 10:07 ? 00:00:03 /usr/libexec/gnome-terminal-server
root 3482 1 3483 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server
root 3482 1 3484 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server
root 3482 1 3487 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server
</code></pre><h2 id=9-显示父进程的子进程>9. 显示父进程的子进程</h2>
<p>这将显示一个进程的所有子进程，并且对于找出从该主要进程中派生了哪些子进程非常有用。</p>
<pre tabindex=0><code># ps -o pid,pcpu,pmem,uname,comm -C apache2
PID %CPU %MEM USER COMMAND
2642 0.0 3.4 www-data apache2
4185 0.0 3.6 www-data apache2
4186 0.0 3.3 www-data apache2
4187 0.0 3.3 www-data apache2
5359 0.0 3.3 www-data apache2
13343 0.0 3.5 www-data apache2
17228 0.0 3.5 www-data apache2
21037 0.0 3.4 www-data apache2
</code></pre><h2 id=10-分层结构中显示进程>10. 分层结构中显示进程</h2>
<p>有时我们希望以分层形式查看进程。为此，我们可以使用 <code>-axjf</code> 选项。</p>
<pre tabindex=0><code>$ ps -axjf
</code></pre><p><img src=http://oss.yuguo.im/blog/202003/ps_axjf.webp alt=按层次显示></p>
<p>或者，我们可以使用的另一个命令是 <code>pstree</code></p>
<p>$ pstree</p>
<p><img src=http://oss.yuguo.im/blog/202003/pstree.webp alt=按层次显示信息></p>
<h2 id=11-显示进程持续运行时间>11. 显示进程持续运行时间</h2>
<p>这将显示一个进程在系统上运行了多长时间。</p>
<pre tabindex=0><code># ps -e -o pid,comm,etime | grep mysql
3107 mysqld_safe 18-07:01:53
3469 mysqld 18-07:01:52
</code></pre><p>我们甚至可以使用以下两个关键字来查找进程实时的正常运行时间。</p>
<ul>
<li><code>etime</code>：自进程启动以后经过的时间，格式为 <code>[[DD-]hh:]mm:ss</code>。</li>
<li><code>etimes</code>：自进程启动以后经过的时间（以秒为单位）。</li>
</ul>
<p>首先，您需要找出进程的 PID。以下命令显示 apache2 的 PID。</p>
<pre tabindex=0><code># pidof apache2
21774
</code></pre><p>现在，我们可以使用以下命令查找此进程已运行多长时间：</p>
<pre tabindex=0><code># ps -p 21774 -o etime
ELAPSED
2-23:31:39
</code></pre><p>您还可以使用 etimes 关键字查看运行时间（以秒为单位），如下所示：</p>
<pre tabindex=0><code># ps -p 21774 -o etimes
ELAPSED
257895
</code></pre><h2 id=12-显示安全信息>12. 显示安全信息</h2>
<p>如果要查看谁当前登录到您的服务器，可以使用 ps 命令查看它。我们可以使用一些选项来满足我们的需求。这里有些例子 ：</p>
<pre tabindex=0><code>$ ps -eo pid,user,args
</code></pre><p><code>-e</code> 选项将显示所有进程，同时 <code>-o</code> 选项将控制输出。Pid, User 和 Args 将向您显示 进程 ID, 运行应用的用户和正在运行的应用。</p>
<p><img src=http://oss.yuguo.im/blog/202003/ps_security_1.webp alt=显示安全信息></p>
<p>可以与 <code>-e</code> 选项一起使用的关键字/用户定义格式为 <code>args，cmd，comm，command，fname，ucmd，ucomm，lstart，bsdstart and start</code>。</p>
<p>现在，ps命令可以通过以下命令将 pid 映射到它们各自的systemd单元。</p>
<pre tabindex=0><code>$ ps -e -o pid，unit，cmd
</code></pre><h2 id=13-以用户格式显示以-root-身份运行的每个进程真实和有效id>13. 以用户格式显示以 root 身份运行的每个进程（真实和有效ID）</h2>
<p>系统管理员可能想查看 root 正在运行哪些进程以及与之相关的其他信息。使用ps命令，我们可以通过以下简单命令进行操作：</p>
<pre tabindex=0><code>$ ps -U root -u root u
</code></pre><p><code>-U</code> 参数将通过实际用户 ID（RUID）选择。它选择真实用户名或 ID 在用户列表中的进程。真实的用户 ID 标识创建进程的用户。</p>
<p>而 <code>-u</code> 参数将通过有效用户ID（EUID）选择</p>
<p>最后一个参数 <code>u</code> 将以面向用户的格式显示输出，其中包含 <code>User, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME and COMMAND</code> 列。</p>
<p>这是上面命令的输出。</p>
<p><img src=http://oss.yuguo.im/blog/202003/ps_root_real_effective_ID.webp alt=显示真实有效的用户ID></p>
<h2 id=14-在实时进程查看器中使用-ps>14. 在实时进程查看器中使用 PS</h2>
<p>ps 将显示有关系统中发生的情况的报告。结果将是静态报告。
假设我们要像上面第 4 点那样按CPU和内存使用情况筛选进程。我们希望报告每1秒更新一次。我们可以组合 <code>watch</code> 命令在 Linux 上做到这一点。</p>
<p>这是命令：</p>
<pre tabindex=0><code>$ watch -n 1 'ps -aux --sort -pmem,-pcpu'
</code></pre><p><img src=http://oss.yuguo.im/blog/202003/watch-ps-1.png alt></p>
<p>如果您认为报告太长，我们可以将其限制为前 20 个流程，例如：我们可以添加 <code>head</code> 命令来做到这一点。</p>
<pre tabindex=0><code>$ watch -n 1 'ps -aux --sort -pmem,-pcpu | head -n 20'
</code></pre><p><img src=http://oss.yuguo.im/blog/202003/watch-ps-20.png alt></p>
<p>这位现场记者当然不像 top 或 htop。但是使用 ps 进行实时报告的优点是您可以自定义字段。您可以选择要查看的字段。</p>
<p>例如，如果只需要显示 pungki 用户，则可以将命令更改为如下所示：</p>
<pre tabindex=0><code>$ watch -n 1 'ps -aux -U pungki u --sort -pmem,-pcpu | head -n 20'
</code></pre><p><img src=http://oss.yuguo.im/blog/202003/ps_watch_3.webp alt>
对于更多文档，您可以在 Linux 控制台上键入 <code>man ps</code> 来探索更多选项。</p>
<div>
<p>扫描下方二维码，关注<code style=color:#1aad19;font-weight:700>Feed</code>， 定期推送最新随笔</p>
<img src=http://oss.xiayuguo.com/wechat_qrcode.jpg style=width:215px;height:215px alt="公众号 Feed 二维码">
</div>
</div>
</div>
<div class=pagination>
<a class="btn previous" href=https://yuguo.im/post/2020/03/errors-explained/> Prev</a>
<a class="btn next" href=https://yuguo.im/post/2020/03/linux-netstat-command-examples/> Next</a>
</div>
</div>
</div>
<div id=disqus_thread></div>
<script>var disqus_config=function(){this.page.url="https://yuguo.im/post/2020/03/linux-ps-command-examples/"};(function(){var a=document,b=a.createElement('script');b.src='//.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments
powered by Disqus.</a></noscript>
<div class=footer>
<p>Copyright@<a href=https://yuguo.im/about>Yuguo</a> 2022. Powered by <a href=https://gohugo.io/>Hugo</a>. This theme—Slim—is open sourced on <a href=https://github.com/zhe/hugo-theme-slim>Github</a>.</p>
</div>
</div>
<script src=https://yuguo.im/js/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-161689466-1','auto'),ga('send','pageview')</script>
</body>
</html>