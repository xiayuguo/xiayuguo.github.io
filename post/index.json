[{"url":"/post/2020/04/iota/","title":"Golang 中关于 iota 的 4 个例子","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/iota/\n iota 基本示例  iota 关键字表示连续的整数常量0、1、2，\u0026hellip; 每当源代码中出现 const 关键字时，它将重置为 0， 并在每个 const 后按规范递增。  const ( C0 = iota C1 = iota C2 = iota ) fmt.Println(C0, C1, C2) // \u0026#34;0 1 2\u0026#34; 这可以简写为\nconst ( C0 = iota C1 C2 ) 这里我们依靠这样的事实，即表达式是在经过简化的 const 声明中隐式重复的 —— 这表示前面的表达式及其类型的重复。\n从 1 开始 要以 1 而不是 0 开头的常量列表，可以在算术表达式中使用 iota。\nconst ( C1 = iota + 1 C2 C3 ) fmt.Println(C1, C2, C3) // \u0026#34;1 2 3\u0026#34; 跳过某个值 您可以使用标识符 _ 跳过常量列表中的值。\nconst ( C1 = iota + 1 _ C3 C4 ) fmt.Println(C1, C3, C4) // \u0026#34;1 3 4\u0026#34; 带有字符串的完整枚举类型[最佳实践] 这是一种实现枚举类型的惯用方式：\n 创建一个新的整数类型， 使用 iota 列出其值， 给类型一个 String 函数。  type Direction int const ( North Direction = iota East South West ) func (d Direction) String() string { return [...]string{\u0026#34;North\u0026#34;, \u0026#34;East\u0026#34;, \u0026#34;South\u0026#34;, \u0026#34;West\u0026#34;}[d] } 使用：\nvar d Direction = North fmt.Print(d) switch d { case North: fmt.Println(\u0026#34; goes up.\u0026#34;) case South: fmt.Println(\u0026#34; goes down.\u0026#34;) default: fmt.Println(\u0026#34; stays put.\u0026#34;) } // Output: North goes up. 命名约定 标准命名约定是对常量也使用混合大写。例如，导出的常量为 NorthWest，而不是 NORTH_WEST。\n延伸阅读 iota 与 \u0026lt;\u0026lt; iota 的另一个常见应用如下\nconst ( B = 1 \u0026lt;\u0026lt; (10 * iota) // 1 (1 \u0026lt;\u0026lt; 10 * 0) \tKB // 1024 (1 \u0026lt;\u0026lt; 10 * 1) \tMB // 1048576 (1 \u0026lt;\u0026lt; 10 * 2) \tGB // 1073741824 (1 \u0026lt;\u0026lt; 10 * 3) \tTB // 1099511627776 (1 \u0026lt;\u0026lt; 40 * 4) \tPB // 1125899906842624 (1 \u0026lt;\u0026lt; 50 * 5) ) "},{"url":"/post/index.json","title":"Posts","content":""},{"url":"/post/2020/04/golang-excel/","title":"How to use Excel with Go","content":"Microsoft Excel™ (XLSX) 是广泛使用的一种电子表格格式。\nGithub 上有两个 Golang 包可以方便读写 Excel 文件。\n    360EntSecGroup-Skylar/excelize tealeg/xlsx     Watch 170 180   Star 6k 4k   Fork 652 657    包 360EntSecGroup-Skylar/excelize 比 tealeg/xlsx 关注度更高，并且 README.md 中有很多示例代码，下面就来看看这个包。\n360EntSecGroup-Skylar/excelize 安装 go get github.com/360EntSecGroup-Skylar/excelize 创建 Excel 文档 官方示例 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/360EntSecGroup-Skylar/excelize\u0026quot; ) func main() { f := excelize.NewFile() // 创建一个工作表 index := f.NewSheet(\u0026quot;Sheet2\u0026quot;) // 设置单元格的值 f.SetCellValue(\u0026quot;Sheet2\u0026quot;, \u0026quot;A2\u0026quot;, \u0026quot;Hello world.\u0026quot;) f.SetCellValue(\u0026quot;Sheet1\u0026quot;, \u0026quot;B2\u0026quot;, 100) // 设置工作簿的默认工作表 f.SetActiveSheet(index) // 根据指定路径保存文件 if err := f.SaveAs(\u0026quot;Book1.xlsx\u0026quot;); err != nil { fmt.Println(err) } } func (f *File) SetCellValue(sheet, axis string, value interface{}) 这个方法只能设置一个单元格的值，而通过查看源码，我们可以看到其实有一个方法 func (f *File) SetSheetRow(sheet, axis string, slice interface{}) 可以设置一行单元格的数据。\n// SetSheetRow writes an array to row by given worksheet name, starting // coordinate and a pointer to array type 'slice'. For example, writes an // array to row 6 start with the cell B6 on Sheet1: // // xlsx.SetSheetRow(\u0026quot;Sheet1\u0026quot;, \u0026quot;B6\u0026quot;, \u0026amp;[]interface{}{\u0026quot;1\u0026quot;, nil, 2}) // Gin 中导出 Excel package main import ( \u0026quot;strconv\u0026quot; \u0026quot;github.com/360EntSecGroup-Skylar/excelize\u0026quot; \u0026quot;github.com/gin-gonic/gin\u0026quot; ) // Export 导出 Excel func Export(c *gin.Context, head []string, body [][]interface{}, filename string) { xlsx := excelize.NewFile() xlsx.SetSheetRow(\u0026quot;Sheet1\u0026quot;, \u0026quot;A1\u0026quot;, \u0026amp;head) for index, rowData := range body{ xlsx.SetSheetRow(\u0026quot;Sheet1\u0026quot;, \u0026quot;A\u0026quot; + strconv.Itoa(index + 2), \u0026amp;rowData) } c.Header(\u0026quot;Content-Type\u0026quot;, \u0026quot;application/octet-stream\u0026quot;) c.Header(\u0026quot;Content-Disposition\u0026quot;, \u0026quot;attachment; filename=\u0026quot; + filename) c.Header(\u0026quot;Content-Transfer-Encoding\u0026quot;, \u0026quot;binary\u0026quot;) _ = xlsx.Write(c.Writer) } func main() { r := gin.Default() r.GET(\u0026quot;/testExport\u0026quot;, func(c *gin.Context) { head := []string{\u0026quot;表头一\u0026quot;, \u0026quot;表头二\u0026quot;, \u0026quot;表头三\u0026quot;} body := [][]interface{}{{1, \u0026quot;2020\u0026quot;, \u0026quot;\u0026quot;}, {2, \u0026quot;2019\u0026quot;, \u0026quot;\u0026quot;}, {3, \u0026quot;2018\u0026quot;, \u0026quot;\u0026quot;}} filename := \u0026quot;test.xlsx\u0026quot; Export(c, head, body, filename) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026quot;localhost:8080\u0026quot;) } 打开浏览器访问 http://localhost:8080/testExport, 直接下载文件 text.xlsx。 读取 Excel 文档 官方示例 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/360EntSecGroup-Skylar/excelize\u0026quot; ) func main() { f, err := excelize.OpenFile(\u0026quot;Book1.xlsx\u0026quot;) if err != nil { fmt.Println(err) return } // 获取工作表中指定单元格的值 cell, err := f.GetCellValue(\u0026quot;Sheet1\u0026quot;, \u0026quot;B2\u0026quot;) if err != nil { fmt.Println(err) return } fmt.Println(cell) // 获取 Sheet1 上所有单元格 rows, err := f.GetRows(\u0026quot;Sheet1\u0026quot;) for _, row := range rows { for _, colCell := range row { fmt.Print(colCell, \u0026quot;\\t\u0026quot;) } fmt.Println() } } "},{"url":"/post/2020/04/pwa-install/","title":"实现 PWA “可安装” 需要什么？","content":" 2020年2月14日发布 · 2020年2月24日更新\n原文作者：Pete LePage\n原文地址：https://web.dev/install-criteria/\n 许多浏览器会向用户表明，当您的渐进式 Web 应用程序（PWA）满足特定条件时，可以安装该程序。示例包括地址栏中的“安装”按钮或弹出菜单中的“安装”菜单项。另外，满足条件时，许多浏览器都会触发 beforeinstallprompt 事件，使您可以直接从 PWA 启用安装流程。\n在 Chrome 浏览器中，您的 Progressive Web App 必须满足以下条件，才能触发 beforeinstallprompt 事件并显示浏览器内安装提示：\n 该 web app 尚未安装 满足用户启发式行为(引导页) 通过 HTTPS 提供服务 包括一个 Web App Manifest，其中包括  short_name 或 name icons - 必须包含 192px 和 512px 图标 start_url display - 必须是指定选项 fullscreen, standalone 或 minimal-ui 中的一个 注: prefer_related_applications 要么不存在，要么值为 false   Registers a service worker with a functional fetch handler  其他浏览器具有类似的安装标准，尽管可能会有细微的差异。检查各个站点以获取完整详细信息：\n Edge Firefox Opera Samsung Internet UC Browser  在 Android 手机上，如果 web app manifest 中包含 related_applications 和 \u0026quot;prefer_related_applications\u0026quot;: true，则会将用户定向到 Google Play 商店，并提示您安装指定的本机应用。\n"},{"url":"/post/2020/04/format-parse-string-time-date-example/","title":"Golang 中格式化时间或日期[完整指南]","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/format-parse-string-time-date-example/\n 基本例子 Go 不使用 yyyy-mm-dd 模式来格式化时间。而是，格式化一个特殊的参数\nMon Jan 2 15:04:05 MST 2006\n与指定的时间或日期格式相同。(当写为 01/02 03:04:05 PM 06 -0700 时，这个日期更容易记住。美式的时间格式 月，日，时，分，秒，年排列起来依次是 1 2 3 4 5 6)\nconst ( layoutISO = \u0026quot;2006-01-02\u0026quot; layoutUS = \u0026quot;January 2, 2006\u0026quot; ) date := \u0026quot;1999-12-31\u0026quot; t, _ := time.Parse(layoutISO, date) fmt.Println(t) // 1999-12-31 00:00:00 +0000 UTC fmt.Println(t.Format(layoutUS)) // December 31, 1999 标准时间和日期格式    Go 格式模板 注释     January 2, 2006 Date   01/02/06    Jan-02-06    15:04:05 Time   3:04:05 PM    Jan _2 15:04:05 Timestamp   Jan _2 15:04:05.000000 with microseconds   2006-01-02T15:04:05-0700 ISO 8601 (RFC 3339)   2006-01-02    15:04:05    02 Jan 06 15:04 MST RFC 822   02 Jan 06 15:04 -0700 with numeric zone   Mon, 02 Jan 2006 15:04:05 MST RFC 1123   Mon, 02 Jan 2006 15:04:05 -0700 with numeric zone    以下预定义的日期和时间戳格式常量也可用。\nANSIC = \u0026quot;Mon Jan _2 15:04:05 2006\u0026quot; UnixDate = \u0026quot;Mon Jan _2 15:04:05 MST 2006\u0026quot; RubyDate = \u0026quot;Mon Jan 02 15:04:05 -0700 2006\u0026quot; RFC822 = \u0026quot;02 Jan 06 15:04 MST\u0026quot; RFC822Z = \u0026quot;02 Jan 06 15:04 -0700\u0026quot; RFC850 = \u0026quot;Monday, 02-Jan-06 15:04:05 MST\u0026quot; RFC1123 = \u0026quot;Mon, 02 Jan 2006 15:04:05 MST\u0026quot; RFC1123Z = \u0026quot;Mon, 02 Jan 2006 15:04:05 -0700\u0026quot; RFC3339 = \u0026quot;2006-01-02T15:04:05Z07:00\u0026quot; RFC3339Nano = \u0026quot;2006-01-02T15:04:05.999999999Z07:00\u0026quot; Kitchen = \u0026quot;3:04PM\u0026quot; // Handy time stamps. Stamp = \u0026quot;Jan _2 15:04:05\u0026quot; StampMilli = \u0026quot;Jan _2 15:04:05.000\u0026quot; StampMicro = \u0026quot;Jan _2 15:04:05.000000\u0026quot; StampNano = \u0026quot;Jan _2 15:04:05.000000000\u0026quot; 模式选项    Type Options     Year 06 2006   Month 01 1 Jan January   Day 02 2 _2 (width two, right justified)   Weekday Mon Monday   Hours 03 3 15   Minutes 04 4   Seconds 05 5   ms μs ns .000 .000000 .000000000   ms μs ns .999 .999999 .999999999 (trailing zeros removed)   am/pm PM pm   Timezone MST   Offset -0700 -07 -07:00 Z0700 Z07:00    个别案例   无法指定以 24 小时制显示不带前导零的小时。\n  无法将午夜指定为 24:00，而不是 00:00。这样做的典型用法是提供开放时间至午夜，例如 07:00 - 24:00。\n  无法指定包含临界秒的时间：23:59:60。实际上，该时间包采用的是公历日历，没有临界秒。\n  "},{"url":"/post/2020/03/shuffle-slice-array/","title":"Golang 中对切片或数组洗牌（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/shuffle-slice-array/\n 包 math/rand 中的 rand.Shuffle 函数使用给定的交换函数对输入序列进行混洗。\na := []int{1, 2, 3, 4, 5, 6, 7, 8} rand.Seed(time.Now().UnixNano()) rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] }) 输出：\n[5 8 6 4 3 7 2 1]  警告：如果不调用 rand.Seed，则每次运行程序时，您都会获得相同的伪随机数序列。\n 延伸阅读 Golang 中生成随机数，字符和切片元素（译文）\nGo 1.10 之前 在包 math/rand 中使用 rand.Seed 和 rand.Intn 函数。\na := []int{1, 2, 3, 4, 5, 6, 7, 8} rand.Seed(time.Now().UnixNano()) for i := len(a) - 1; i \u0026gt; 0; i-- { // Fisher–Yates shuffle  j := rand.Intn(i + 1) a[i], a[j] = a[j], a[i] } "},{"url":"/post/2020/04/how-to-sort-in-go/","title":"Golang 中的 3 种排序方式（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/how-to-sort-in-go/\n 对整数，浮点数或字符串的切片进行排序 使用下面与其类型对应的方法\n sort.Ints sort.Float64s sort.Strings  s := []int{4, 2, 3, 1} sort.Ints(s) fmt.Println(s) // [1 2 3 4]  包 radix 是对 sort.Strings 的一种替代方案。在某些情况, 它可以快两倍以上。\n 用自定义比较器排序  使用函数 sort.Slice。它使用提供的功能 less(i, j int) bool 对切片进行排序。 要在保留相等元素的原始顺序的同时对切片进行排序，请改用 sort.SliceStable。  family := []struct { Name string Age int }{ {\u0026quot;Alice\u0026quot;, 23}, {\u0026quot;David\u0026quot;, 2}, {\u0026quot;Eve\u0026quot;, 2}, {\u0026quot;Bob\u0026quot;, 25}, } // Sort by age, keeping original order or equal elements. sort.SliceStable(family, func(i, j int) bool { return family[i].Age \u0026lt; family[j].Age }) fmt.Println(family) // [{David 2} {Eve 2} {Alice 23} {Bob 25}] 自定义数据结构排序  使用通用的 sort.Sort 和 sort.Stable 函数。 他们对实现 sort.Interface 接口的任何集合进行排序。  type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } 这里有一个示例。\ntype Person struct { Name string Age int } // ByAge implements sort.Interface based on the Age field. type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Less(i, j int) bool { return a[i].Age \u0026lt; a[j].Age } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func main() { family := []Person{ {\u0026quot;Alice\u0026quot;, 23}, {\u0026quot;Eve\u0026quot;, 2}, {\u0026quot;Bob\u0026quot;, 25}, } sort.Sort(ByAge(family)) fmt.Println(family) // [{Eve 2} {Alice 23} {Bob 25}] } 福利: 按键或值对 Map 排序 map 是键值对的无序集合。如果需要稳定的迭代顺序，则必须维护单独的数据结构。\n下面的代码示例：使用键构造一个切片, 再按键顺序对 map 进行排序。\nm := map[string]int{\u0026quot;Alice\u0026quot;: 2, \u0026quot;Cecil\u0026quot;: 1, \u0026quot;Bob\u0026quot;: 3} keys := make([]string, 0, len(m)) for k := range m { keys = append(keys, k) } sort.Strings(keys) for _, k := range keys { fmt.Println(k, m[k]) } // Output: // Alice 2 // Bob 3 // Cecil 1  同样，从 Go 1.12 开始，fmt 包以键排序的顺序打印 map 以简化测试。\n 性能和实现 Go 排序包中的所有算法在最坏的情况下都进行时间复杂度为 O(nlogn) 的比较，其中 n 是要排序的元素数。\n大多数功能是使用快速排序的优化版本实现的。\n"},{"url":"/post/2020/03/linux-netstat-command-examples/","title":"10 个 Linux netstat 命令实战","content":" 作者：Silver Moon\n原文网址：https://www.binarytides.com/linux-netstat-command-examples/\n Netstat Netstat 是一个命令行实用程序，可用于列出系统上的所有网络（socket）连接。它列出了所有的 tcp，udp socket 连接和 unix socket 连接。\n除了已连接的套接字外，它还可以列出正在等待传入连接的侦听套接字。因此，通过验证开放端口 80，可以确认 Web 服务器是否在系统上运行。这使得它成为网络和系统管理员非常有用的工具。\n在本教程中，我们将查证一些示例，说明如何使用 netstat 查找有关网络连接和系统上开放端口的信息。\n这是手册（man pages）中对 netstat 的简介\nnetstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships 1. 列出所有连接 第一个也是最简单的命令是列出所有当前连接。只需使用 a 选项运行 netstat 命令。\n$ netstat -a Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN tcp 0 0 localhost:ipp *:* LISTEN tcp 0 0 enlightened.local:54750 li240-5.members.li:http ESTABLISHED tcp 0 0 enlightened.local:49980 del01s07-in-f14.1:https ESTABLISHED tcp6 0 0 ip6-localhost:ipp [::]:* LISTEN udp 0 0 enlightened:domain *:* udp 0 0 *:bootpc *:* udp 0 0 enlightened.local:ntp *:* udp 0 0 localhost:ntp *:* udp 0 0 *:ntp *:* udp 0 0 *:58570 *:* udp 0 0 *:mdns *:* udp 0 0 *:49459 *:* udp6 0 0 fe80::216:36ff:fef8:ntp [::]:* udp6 0 0 ip6-localhost:ntp [::]:* udp6 0 0 [::]:ntp [::]:* udp6 0 0 [::]:mdns [::]:* udp6 0 0 [::]:63811 [::]:* udp6 0 0 [::]:54952 [::]:* Active UNIX domain sockets (servers and established) Proto RefCnt Flags Type State I-Node Path unix 2 [ ACC ] STREAM LISTENING 12403 @/tmp/dbus-IDgfj3UGXX unix 2 [ ACC ] STREAM LISTENING 40202 @/dbus-vfs-daemon/socket-6nUC6CCx 上面的命令显示了来自不同协议（例如 tcp，udp 和 unix 套接字）的所有连接。但是，这不是很有用。管理员通常希望例如根据协议或端口号选择特定的连接。\n2. 仅列出 TCP 或 UDP 连接 要仅列出 tcp 连接，请使用 t 选项。\n$ netstat -at Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 enlightened:domain *:* LISTEN tcp 0 0 localhost:ipp *:* LISTEN tcp 0 0 enlightened.local:36310 del01s07-in-f24.1:https ESTABLISHED tcp 0 0 enlightened.local:45038 a96-17-181-10.depl:http ESTABLISHED tcp 0 0 enlightened.local:37892 ABTS-North-Static-:http ESTABLISHED ..... 与仅列出 udp 连接类似，请使用 u 选项。\n$ netstat -au Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State udp 0 0 *:34660 *:* udp 0 0 enlightened:domain *:* udp 0 0 *:bootpc *:* udp 0 0 enlightened.local:ntp *:* udp 0 0 localhost:ntp *:* udp 0 0 *:ntp *:* udp6 0 0 fe80::216:36ff:fef8:ntp [::]:* udp6 0 0 ip6-localhost:ntp [::]:* udp6 0 0 [::]:ntp [::]:* 上面的输出显示了ipv4和ipv6连接。\n3. 禁用反向 DNS 查找以加快输出速度 默认情况下，netstat 命令尝试通过反向 DNS 查找来找出连接中每个 IP 地址的主机名。这会减慢输出速度。如果您不需要知道主机名，仅使用 ip 地址就足够了，那么请使用 n 选项禁止查找主机名。\n$ netstat -ant Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN tcp 0 0 192.168.1.2:49058 173.255.230.5:80 ESTABLISHED tcp 0 0 192.168.1.2:33324 173.194.36.117:443 ESTABLISHED tcp6 0 0 ::1:631 :::* LISTEN 上面的命令显示了所有没有 DNS 解析的 TCP 连接。明白了么？很好，我们继续。\n4. 仅列出监听连接 任何网络守护程序/服务都会保留一个开放端口以侦听传入的连接。这些也类似于套接字连接，并由 netstat 列出。要仅查看监听端口，请使用 l (助记单词 listen) 选项。\n$ netstat -tnl Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN tcp6 0 0 ::1:631 :::* LISTEN 现在，我们只能看到正在监听的 tcp 端口/连接。如果要查看所有监听端口，请删除 t 选项。如果只想监听 udp 端口，请使用 u 选项而不是 t。确保删除 a 选项，否则将列出所有连接，而不仅仅是监听连接。\n5. 获取进程名称 / pid和用户 ID 在查看打开/监听端口和连接时，了解打开该端口或连接的进程名称 / pid 通常很有用。例如，Apache httpd 服务器打开了端口 80。因此，如果要检查是否正在运行任何 http 服务器，或者正在运行的是 apache 或 nginx，则要查找哪个 http 服务器，然后查找进程名称。\n可以通过 p 选项获得过程详细信息。\n$ sudo netstat -nlpt Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN 1144/dnsmasq tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 661/cupsd tcp6 0 0 ::1:631 :::* LISTEN 661/cupsd 使用 p 选项时，netstat 必须以 root 特权运行，否则 netstat 无法检测以 root 特权运行的进程的 pid，大多数服务（如 http 和 ftp）通常以 root 特权运行。\n连同进程名称 / pid 一起使用，对于拥有该特定进程的用户名 / uid 更为有用。同时使用 e 选项和 p 选项来获取用户名。\n$ sudo netstat -ltpe Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State User Inode PID/Program name tcp 0 0 enlightened:domain *:* LISTEN root 11090 1144/dnsmasq tcp 0 0 localhost:ipp *:* LISTEN root 9755 661/cupsd tcp6 0 0 ip6-localhost:ipp [::]:* LISTEN root 9754 661/cupsd 上面的示例列出了 Tcp 类型的监听连接以及进程信息和扩展信息。\n扩展信息包含进程的用户名和索引节点。这对网络管理员是有用的命令。\n注 - 如果将 n 选项与 e 选项一起使用，则将列出 uid 而不是用户名。\n6. 打印统计 netstat 命令还可以打印出网络统计信息，例如按协议类型接收和发送的数据包总数等。\n列出所有数据包类型的统计信息\n$ netstat -s Ip: 32797 total packets received 0 forwarded 0 incoming packets discarded 32795 incoming packets delivered 29115 requests sent out 60 outgoing packets dropped Icmp: 125 ICMP messages received 0 input ICMP message failed. ICMP input histogram: destination unreachable: 125 125 ICMP messages sent 0 ICMP messages failed ICMP output histogram: destination unreachable: 125 ... OUTPUT TRUNCATED ... 要仅输出诸如 TCP 或 UDP 之类的选定协议的统计信息，请使用相应的选项（如 t 和 u 以及 s 选项）。简单！\n7. 显示内核路由信息 可以使用 r 选项来打印内核路由信息。它与 route 命令给定的输出相同。我们还使用 n 选项禁用主机名查找。\n$ netstat -rn Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface 0.0.0.0 192.168.1.1 0.0.0.0 UG 0 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 8. 打印网络接口 netstat 命令还可以打印出有关网络接口的信息。 i 选项可以实现这个任务。\n$ netstat -i Kernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg eth0 1500 0 31611 0 0 0 27503 0 0 0 BMRU lo 65536 0 2913 0 0 0 2913 0 0 0 LRU 上面的输出包含非常原始格式的信息。要获得更人性化的输出版本，请使用 e 选项和 i 选项。\n$ netstat -ie Kernel Interface table eth0 Link encap:Ethernet HWaddr 00:16:36:f8:b2:64 inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::216:36ff:fef8:b264/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:31682 errors:0 dropped:0 overruns:0 frame:0 TX packets:27573 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:29637117 (29.6 MB) TX bytes:4590583 (4.5 MB) Interrupt:18 Memory:da000000-da020000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:2921 errors:0 dropped:0 overruns:0 frame:0 TX packets:2921 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:305297 (305.2 KB) TX bytes:305297 (305.2 KB) 上面的输出类似于 ifconfig 命令显示的输出\n9. 连续获取 netstat 输出 Netstat 可以使用 c 选项连续输出连接信息。\n$ netstat -ct 上面的命令将连续输出 tcp 连接。\n10. 显示多播组信息 g 选项将显示 IPv4 和 IPv6 协议的多播组信息。\n$ netstat -g IPv6/IPv4 Group Memberships Interface RefCnt Group --------------- ------ --------------------- lo 1 all-systems.mcast.net eth0 1 224.0.0.251 eth0 1 all-systems.mcast.net lo 1 ip6-allnodes lo 1 ff01::1 eth0 1 ff02::fb eth0 1 ff02::1:fff8:b264 eth0 1 ip6-allnodes eth0 1 ff01::1 wlan0 1 ip6-allnodes wlan0 1 ff01::1 Netstat 命令的更多示例 好的，我们涵盖了上面的 netstat 命令的基本示例。现在是时候用样式来做一些怪胎了。\n打印活动连接 活动的套接字连接处于 “ESTABLISHED” 状态。因此，要获得所有当前的活动连接，请使用 netstat 和 grep，如下所示\n$ netstat -atnp | grep ESTA (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) tcp 0 0 192.168.1.2:49156 173.255.230.5:80 ESTABLISHED 1691/chrome tcp 0 0 192.168.1.2:33324 173.194.36.117:443 ESTABLISHED 1691/chrome 要监视连续的活动连接列表，请使用watch命令以及netstat和grep\n$ watch -d -n0 \u0026quot;netstat -atnp | grep ESTA\u0026quot; 检查服务是否正在运行 如果要检查 http，smtp 或 ntp 之类的服务器是否正在运行，请再次使用 grep。\n$ sudo netstat -aple | grep ntp udp 0 0 enlightened.local:ntp *:* root 17430 1789/ntpd udp 0 0 localhost:ntp *:* root 17429 1789/ntpd udp 0 0 *:ntp *:* root 17422 1789/ntpd udp6 0 0 fe80::216:36ff:fef8:ntp [::]:* root 17432 1789/ntpd udp6 0 0 ip6-localhost:ntp [::]:* root 17431 1789/ntpd udp6 0 0 [::]:ntp [::]:* root 17423 1789/ntpd unix 2 [ ] DGRAM 17418 1789/ntpd 因此，我们发现 ntp 服务器正在运行。 http 或 smtp 或任何您正在寻找服务都可以使用 grep 来查看。\n好吧，这就是 netstat 的用途。如果您正在寻找更高级的信息或想深入了解，请阅读 netstat 手册（man netstat）。\n并在下面的评论框中留下您的反馈和建议。\n最后更新时间：2014年12月25日\n"},{"url":"/post/2020/03/linux-ps-command-examples/","title":"14 个重要的 Linux ps 命令实战","content":" 作者：Pungki Arianto\n原文网址：https://linoxide.com/how-tos/linux-ps-command-examples/\n Linux ps 命令是用于捕获系统上当前进程的内置工具。它将一次捕获系统状况。如果您想实时进行刷新，可以使用 top 命令。\n在本教程中，我将向您展示 ps 命令的常见实际示例，该示例有助于您的日常linux系统管理。\n1. 不带任何选项运行 ps 这是非常基本的 ps 用法。只需在控制台上键入 ps 即可查看其结果。\nroot@ParkW:~# ps PID TTY TIME CMD 28269 pts/1 00:00:00 bash 28307 pts/1 00:00:00 ps 默认情况下，它将向我们显示 4 列信息。\n PID 是运行命令（CMD）的进程 ID TTY 是运行命令的地方 TIME 是运行命令时 CPU 使用了多少时间 CMD 是进程运行的命令  这里的信息展示是无序的。\n2. 显示当前所有进程 为此，我们可以使用 -a 选项。我们可以猜到, -a 是 all 的简写。选项 x 将显示所有进程，即使当前进程也未与任何TTY（终端）相关联\n$ ps -ax 该结果可能会比较多。为了使其更易于阅读，请将其与 less 命令结合使用。\n$ ps -ax | less  PID TTY STAT TIME COMMAND 1 ? Ss 0:12 /sbin/init 2 ? S 0:00 [kthreadd] 3 ? S 1:02 [ksoftirqd/0] 5 ? S\u0026lt; 0:00 [kworker/0:0H] 7 ? S 28:50 [rcu_preempt] 8 ? S 0:00 [rcu_sched] 9 ? S 0:00 [rcu_bh] 10 ? S 0:04 [migration/0] 11 ? S 0:04 [migration/1] 12 ? S 0:09 [ksoftirqd/1] 14 ? S\u0026lt; 0:00 [kworker/1:0H] 15 ? S 0:04 [migration/2] 16 ? S 0:09 [ksoftirqd/2] 18 ? S\u0026lt; 0:00 [kworker/2:0H] 19 ? S 0:04 [migration/3] 20 ? S 0:09 [ksoftirqd/3] : 3. 按用户过滤进程 在某些情况下，我们可能希望按用户筛选进程。为此，我们可以使用 -u 选项。假设我们要查看用户 root 运行哪些进程。所以命令如下：\n$ ps -u root root@ParkW:~# ps -u root PID TTY TIME CMD 1 ? 00:00:12 init 2 ? 00:00:00 kthreadd 3 ? 00:01:02 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 7 ? 00:28:50 rcu_preempt 4. 按 CPU 或内存使用情况过滤进程 您可能希望看到的另一件事是按 CPU 或内存使用情况过滤结果。这样，您可以获取哪些进程消耗了资源的信息。为此，我们可以使用 aux 选项。这是一个例子：\n$ ps -aux | less USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 3264 2460 ? Ss 3月12 0:12 /sbin/init root 2 0.0 0.0 0 0 ? S 3月12 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? S 3月12 1:02 [ksoftirqd/0] root 5 0.0 0.0 0 0 ? S\u0026lt; 3月12 0:00 [kworker/0:0H] root 7 0.1 0.0 0 0 ? S 3月12 28:51 [rcu_preempt] root 8 0.0 0.0 0 0 ? S 3月12 0:00 [rcu_sched] root 9 0.0 0.0 0 0 ? S 3月12 0:00 [rcu_bh] root 10 0.0 0.0 0 0 ? S 3月12 0:04 [migration/0] root 11 0.0 0.0 0 0 ? S 3月12 0:04 [migration/1] root 12 0.0 0.0 0 0 ? S 3月12 0:09 [ksoftirqd/1] 显示所有信息\n由于结果可以在很长的列表中，因此我们可以将pipe较少的命令转换为ps命令。解释结果中的每个术语。\n USER - Username ：与进程关联的用户名。 PID - Process ID ：分配给进程的唯一数字标识符。 %CPU - Percentage of CPU ：CPU 使用时间的百分比（CPU 总时间除以进程已运行的时间长度）。 %MEM - Percentage of RAM Memory 内存使用百分比（已用内存除以可用总内存）。 VSZ - Virtual Memory Size ：虚拟内存中进程的大小, 以 KiB 表示。 RSS - Resident Set Size。 TTY - Terminal controlling the process。 STAT - Process State - Possible values。  R - Running。 S - Sleeping（可能会中断）。 D - Sleeping（可能不会被打断）- 用于表示进程正在处理输入/输出。 T - Stopped or being traced。 Z - Zombie or \u0026ldquo;hung\u0026rdquo; process. - 僵尸或“挂起”进程。   START ：进程开始的日期或时间。 TIME ：该进程以及该进程启动的子进程使用累积的CPU时间。 COMMAND ：启动进程的命令。  默认情况下，结果是无序的。如果要按特定列排序，可以将 --sort 选项添加到 ps 命令中。\n按最高 CPU utilization 升序排列\n$ ps -aux --sort -pcpu | less USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1116 2.3 0.8 31916 18036 ? S 3月12 410:07 /usr/bin/python /usr/local/bin/xxx_serviceA root 14106 1.4 2.2 199660 45748 ? Sl 3月23 15:16 /usr/bin/python /usr/local/bin/xxx_serviceB mongodb 5844 0.7 1.9 236996 39820 ? Ssl 3月16 82:20 /usr/bin/mongod --config /etc/mongodb.conf mysql 721 0.4 3.9 349636 82448 ? Ssl 3月12 70:29 /usr/sbin/mysqld root 14095 0.4 2.6 74296 55280 ? S 3月23 4:43 /usr/bin/python /usr/local/bin/xxx_serviceC redis 787 0.3 0.1 26836 2332 ? Ssl 3月12 66:04 /usr/bin/redis-server 0.0.0.0:6379 按最高 Memory utilization 升序排序\n$ ps -aux --sort -pmem | less USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 930 0.2 21.2 1213260 437348 ? Sl 3月12 40:13 /root/xxx/javaService start mysql 721 0.4 3.9 349636 82448 ? Ssl 3月12 70:31 /usr/sbin/mysqld root 14099 0.0 3.1 116364 64776 ? S 3月23 0:46 /usr/bin/python /usr/local/bin/xxx_Service root 14095 0.4 2.6 74296 55280 ? S 3月23 4:44 /usr/bin/python /usr/local/bin/xxx_ServiceB 或者我们可以将其组合为一个命令，并仅显示结果的前十位：\n$ ps -aux --sort -pcpu,+pmem | head -n 10 5. 前十大内存消耗的进程 这显示了系统上运行的前 10 个内存消耗进程。查看哪些进程最消耗内存是很有用的。\nOptions: --sort spec specifies sorting order. Sorting syntax is [+|-]key[,[+|-]key[,...]]. Choose a multi-letter key from the STANDARD FORMAT SPECIFIERS section. The \u0026quot;+\u0026quot; is optional since default direction is increasing numerical or lexicographic order. Identical to k. For example: ps jax --sort=uid,-ppid,+pid # ps -auxf | sort -nr -k 4 | head -10 root 3025 3.2 13.0 1600004 245276 ? Sl 10:00 2:01 \\_ /usr/bin/gnome-shell root 2261 0.5 1.8 188108 34540 tty1 Rs+ 09:49 0:25 \\_ /usr/bin/Xorg :0 -background none -verbose -auth /run/gdm/auth-for-gdm-fTksZM/database -seat seat0 -nolisten tcp vt1 root 3089 0.0 1.2 1060728 22608 ? Sl 10:00 0:00 /usr/bin/nautilus --no-default-window root 2957 0.0 1.2 998384 23244 ? Sl 10:00 0:00 \\_ /usr/libexec/gnome-settings-daemon root 3482 0.0 1.0 632688 19344 ? Rl 10:07 0:02 /usr/libexec/gnome-terminal-server root 3181 0.1 1.0 349960 20280 ? S 10:00 0:07 /usr/bin/vmtoolsd -n vmusr root 802 0.0 0.9 550008 18036 ? Ssl 09:49 0:01 /usr/bin/python -Es /usr/sbin/tuned -l -P root 950 0.0 0.8 102312 15580 ? S 09:49 0:00 \\_ /sbin/dhclient -d -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient-eno16777736.pid -lf /var/lib/NetworkManager/dhclient-42456ebc-a752-4950-9adf-1b8bc29f43eb-eno16777736.lease -cf /var/lib/NetworkManager/dhclient-eno16777736.conf eno16777736 root 3154 0.0 0.8 898940 15300 ? Sl 10:00 0:00 /usr/libexec/evolution-calendar-factory root 3020 0.0 0.8 551480 16420 ? Sl 10:00 0:00 /usr/libexec/goa-daemon 6. 按名称或进程ID过滤进程 为此，我们可以使用 -C 选项, 关键字放在它后面。假设我们要显示名为 getty 的进程。我们可以输入：\n$ ps -C getty root@ParkW:~# ps -C getty PID TTY TIME CMD 628 ttySAC0 00:00:00 getty 如果要显示有关结果的更多详细信息，可以添加 -f 选项, 以在完整格式列表中显示它。上面的命令如下所示：\n$ ps -f -C getty root@ParkW:~# ps -f -C getty UID PID PPID C STIME TTY TIME CMD root 628 1 0 3月12 ttySAC0 00:00:00 /sbin/getty 115200 ttySAC0 7. 通过进程的线程过滤进程 如果我们需要了解特定进程的线程，可以使用 -L选项, 其后跟进程 ID（PID）。这是一个实际的例子：\n$ ps -L 1213 可以看到，PID保持相同的值，但是显示线程数的LWP显示不同的值。\n8. 显示特定进程 ID 的所有线程 这将显示特定进程pid的所有线程。\nOptions: -L show threads possibly with LWP and NLWP columns. # ps -Lf -p 3482 UID PID PPID LWP C NLWP STIME TTY TIME CMD root 3482 1 3482 0 4 10:07 ? 00:00:03 /usr/libexec/gnome-terminal-server root 3482 1 3483 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server root 3482 1 3484 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server root 3482 1 3487 0 4 10:07 ? 00:00:00 /usr/libexec/gnome-terminal-server 9. 显示父进程的子进程 这将显示一个进程的所有子进程，并且对于找出从该主要进程中派生了哪些子进程非常有用。\n# ps -o pid,pcpu,pmem,uname,comm -C apache2 PID %CPU %MEM USER COMMAND 2642 0.0 3.4 www-data apache2 4185 0.0 3.6 www-data apache2 4186 0.0 3.3 www-data apache2 4187 0.0 3.3 www-data apache2 5359 0.0 3.3 www-data apache2 13343 0.0 3.5 www-data apache2 17228 0.0 3.5 www-data apache2 21037 0.0 3.4 www-data apache2 10. 分层结构中显示进程 有时我们希望以分层形式查看进程。为此，我们可以使用 -axjf 选项。\n$ ps -axjf 或者，我们可以使用的另一个命令是 pstree\n$ pstree\n11. 显示进程持续运行时间 这将显示一个进程在系统上运行了多长时间。\n# ps -e -o pid,comm,etime | grep mysql 3107 mysqld_safe 18-07:01:53 3469 mysqld 18-07:01:52 我们甚至可以使用以下两个关键字来查找进程实时的正常运行时间。\n etime：自进程启动以后经过的时间，格式为 [[DD-]hh:]mm:ss。 etimes：自进程启动以后经过的时间（以秒为单位）。  首先，您需要找出进程的 PID。以下命令显示 apache2 的 PID。\n# pidof apache2 21774 现在，我们可以使用以下命令查找此进程已运行多长时间：\n# ps -p 21774 -o etime ELAPSED 2-23:31:39 您还可以使用 etimes 关键字查看运行时间（以秒为单位），如下所示：\n# ps -p 21774 -o etimes ELAPSED 257895 12. 显示安全信息 如果要查看谁当前登录到您的服务器，可以使用 ps 命令查看它。我们可以使用一些选项来满足我们的需求。这里有些例子 ：\n$ ps -eo pid,user,args -e 选项将显示所有进程，同时 -o 选项将控制输出。Pid, User 和 Args 将向您显示 进程 ID, 运行应用的用户和正在运行的应用。\n可以与 -e 选项一起使用的关键字/用户定义格式为 args，cmd，comm，command，fname，ucmd，ucomm，lstart，bsdstart and start。\n现在，ps命令可以通过以下命令将 pid 映射到它们各自的systemd单元。\n$ ps -e -o pid，unit，cmd 13. 以用户格式显示以 root 身份运行的每个进程（真实和有效ID） 系统管理员可能想查看 root 正在运行哪些进程以及与之相关的其他信息。使用ps命令，我们可以通过以下简单命令进行操作：\n$ ps -U root -u root u -U 参数将通过实际用户 ID（RUID）选择。它选择真实用户名或 ID 在用户列表中的进程。真实的用户 ID 标识创建进程的用户。\n而 -u 参数将通过有效用户ID（EUID）选择\n最后一个参数 u 将以面向用户的格式显示输出，其中包含 User, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME and COMMAND 列。\n这是上面命令的输出。\n14. 在实时进程查看器中使用 PS ps 将显示有关系统中发生的情况的报告。结果将是静态报告。 假设我们要像上面第 4 点那样按CPU和内存使用情况筛选进程。我们希望报告每1秒更新一次。我们可以组合 watch 命令在 Linux 上做到这一点。\n这是命令：\n$ watch -n 1 'ps -aux --sort -pmem,-pcpu' 如果您认为报告太长，我们可以将其限制为前 20 个流程，例如：我们可以添加 head 命令来做到这一点。\n$ watch -n 1 'ps -aux --sort -pmem,-pcpu | head -n 20' 这位现场记者当然不像 top 或 htop。但是使用 ps 进行实时报告的优点是您可以自定义字段。您可以选择要查看的字段。\n例如，如果只需要显示 pungki 用户，则可以将命令更改为如下所示：\n$ watch -n 1 'ps -aux -U pungki u --sort -pmem,-pcpu | head -n 20' 对于更多文档，您可以在 Linux 控制台上键入 man ps 来探索更多选项。\n"},{"url":"/post/2020/03/errors-explained/","title":"Golang 错误处理最佳实践（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/errors-explained/\n Go 具有两种不同的错误处理机制：\n 大多数函数返回 errors； 只有真正无法恢复的条件（例如超出范围的索引）才会产生运行时异常，我们称之为 panic  Go 的多值返回值使您可以轻松地在正常返回值旁边返回详细的错误消息。按照惯例，此类消息具有类型 error，这是一个简单的内置 interface：\ntype error interface { Error() string } 错误处理示例 os.Open 函数无法打开文件时返回一个非 nil 错误值。\nfunc Open(name string) (file *File, err error) 以下代码使用 os.Open 打开文件。如果发生错误，它将调用 log.Fatal 打印错误消息并停止。\nf, err := os.Open(\u0026quot;filename.ext\u0026quot;) if err != nil { log.Fatal(err) } // do something with the open *File f 自定义错误 要创建简单的仅字符串 error，可以使用 errors.New：\nerr := errors.New(\u0026quot;Houston, we have a problem\u0026quot;) error 接口仅需要一个 Error 方法，但是特定的 error 实现通常具有其他方法，从而允许调用方检查错误的详细信息。\n学到更多 有关更多示例，请参见 3种创建错误的简单方法。\nPanic Panics 类似于 C++ 和 Java 异常，但仅适用于运行时错误，例如跟随一个 nil 指针或试图对数组访问超出范围的索引。\n延伸阅读 有关如何从 panics 中恢复和测试 panics 的教程，请参见 从 panic 中恢复。\n"},{"url":"/post/2020/03/recover-from-panic/","title":"Panic,堆栈跟踪以及如何恢复【最佳实践】（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/recover-from-panic/\n Panic 是 Go 中的一个异常 Panics 类似于 C++ 和 Java 异常，但仅适用于运行时错误，例如跟随一个 nil 指针或试图对数组访问超出范围的索引。为了表示诸如文件结束之类的事件，Go 程序使用内置 error 类型。有关错误的更多信息，请参见 错误处理最佳实践 和 3种创建错误的简单方法。\nPanic 停止 goroutine 的正常执行\n 程序出现 panic 时，它将立即开始展开调用堆栈。 一直持续到程序崩溃并打印堆栈跟踪, 或直到调用内置的恢复功能。  panic 是由运行时错误或对内置函数 panic 的显式调用引起的。\n堆栈跟踪记录 堆栈跟踪记录 —— 所有活动堆栈帧的报告 —— 通常在 panic 发生时将其打印到控制台。堆栈跟踪对于调试非常有用：\n 您不仅可以看到错误发生的地方， 而且可以看到程序是如何到达这个地方的。  解释堆栈跟踪 这是一个堆栈跟踪的示例：\ngoroutine 11 [running]: testing.tRunner.func1(0xc420092690) /usr/local/go/src/testing/testing.go:711 +0x2d2 panic(0x53f820, 0x594da0) /usr/local/go/src/runtime/panic.go:491 +0x283 github.com/yourbasic/bit.(*Set).Max(0xc42000a940, 0x0) ../src/github.com/bit/set_math_bits.go:137 +0x89 github.com/yourbasic/bit.TestMax(0xc420092690) ../src/github.com/bit/set_test.go:165 +0x337 testing.tRunner(0xc420092690, 0x57f5e8) /usr/local/go/src/testing/testing.go:746 +0xd0 created by testing.(*T).Run /usr/local/go/src/testing/testing.go:789 +0x2de 可以从下至上阅读：\n testing.(*T).Run 调用了 testing.tRunner, testing.tRunner 调用了 bit.TestMax, bit.TestMax 调用了 bit.(*Set).Max, bit.(*Set).Max 调用了 panic, panic 调用了 testing.tRunner.func1  缩进的行显示了调用该函数的源文件和行号。十六进制数字表示参数值，包括指针和内部数据结构的值。Go 中的堆栈跟踪 具有更多详细信息。\n打印并记录堆栈跟踪 要打印当前 goroutine 的堆栈跟踪，请使用包 runtime/debug 中的debug.PrintStack。\n您还可以通过调用 runtime.Stack 以编程方式检查当前的堆栈跟踪\n详细程度 变量 GOTRACEBACK 控制 Go 程序失败时生成的输出量。\n GOTRACEBACK = none 完全忽略 goroutine 堆栈跟踪。 GOTRACEBACK = single（默认）为当前goroutine打印堆栈跟踪, 从而消除运行时系统内部的功能。如果没有当前goroutine或故障是运行时内部的，则故障会打印所有goroutine的堆栈跟踪。 GOTRACEBACK = all 为所有用户创建的goroutine添加堆栈跟踪。 GOTRACEBACK = system 与其他系统一样，但是为运行时函数添加了堆栈框架，并显示了运行时在内部创建的 goroutine。  恢复和捕获 Panic 内置的 recover 函数可用于重新获得对异常程序的控制并恢复正常执行。\n 调用 recover 将停止展开并返回传递给 panic 的参数。 如果 goroutine 没有异常，则恢复将返回 nil。  因为展开时运行的唯一代码是在 defer 函数内部，所以 recover 仅在此类函数内部有用。\nPanic 处理程序示例 func main() { n := foo() fmt.Println(\u0026quot;main received\u0026quot;, n) } func foo() int { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() m := 1 panic(\u0026quot;foo: fail\u0026quot;) m = 2 return m } foo: fail main received 0 由于 panic 是在 foo 返回值之前发生的，因此 n 仍然具有其初始零值。\n返回值 要在发生 panic 时返回值，必须使用命名返回值。\nfunc main() { n := foo() fmt.Println(\u0026quot;main received\u0026quot;, n) } func foo() (m int) { defer func() { if err := recover(); err != nil { fmt.Println(err) m = 2 } }() m = 1 panic(\u0026quot;foo: fail\u0026quot;) m = 3 return m } foo: fail main received 2 测试 Panic（实用功能） 在此示例中，我们使用反射来检查接口变量列表是否具有与给定函数的参数相对应的类型。如果是这样，我们使用这些参数调用该函数以检查是否有 panic。\n// Panics tells if function f panics with parameters p. func Panics(f interface{}, p ...interface{}) bool { fv := reflect.ValueOf(f) ft := reflect.TypeOf(f) if ft.NumIn() != len(p) { panic(\u0026quot;wrong argument count\u0026quot;) } pv := make([]reflect.Value, len(p)) for i, v := range p { if reflect.TypeOf(v) != ft.In(i) { panic(\u0026quot;wrong argument type\u0026quot;) } pv[i] = reflect.ValueOf(v) } return call(fv, pv) } func call(fv reflect.Value, pv []reflect.Value) (b bool) { defer func() { if err := recover(); err != nil { b = true } }() fv.Call(pv) return } "},{"url":"/post/2020/03/create-error/","title":"Golang 中 3 种简单的方法来创建错误（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/create-error/\n 基于字符串的错误 标准库提供了两个现成的选项。\n// simple string-based error err1 := errors.New(\u0026quot;math: square root of negative number\u0026quot;) // with formatting err2 := fmt.Errorf(\u0026quot;math: square root of negative number %g\u0026quot;, x) 带有数据的自定义错误 要定义自定义错误类型，您必须满足预先声明的 error 接口。\ntype error interface { Error() string } 这里有两个例子。\ntype SyntaxError struct { Line int Col int } func (e *SyntaxError) Error() string { return fmt.Sprintf(\u0026quot;%d:%d: syntax error\u0026quot;, e.Line, e.Col) } type InternalError struct { Path string } func (e *InternalError) Error() string { return fmt.Sprintf(\u0026quot;parse %v: internal error\u0026quot;, e.Path) } 如果 Foo 是可以返回 SyntaxError 或 InternalError 的函数，则可以处理两种情况。\nif err := Foo(); err != nil { switch e := err.(type) { case *SyntaxError: // Do something interesting with e.Line and e.Col. case *InternalError: // Abort and file an issue. default: log.Println(e) } } "},{"url":"/post/2020/03/interface-to-string/","title":"Golang 中将接口转换为字符串（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/interface-to-string/\n 使用 fmt.Sprintf 将interface value转换为字符串。\nvar x interface{} = \u0026quot;abc\u0026quot; str := fmt.Sprintf(\u0026quot;%v\u0026quot;, x) 实际上，可以使用相同的技术来获取任何数据结构的字符串表示形式。\nvar x interface{} = []int{1, 2, 3} str := fmt.Sprintf(\u0026quot;%v\u0026quot;, x) fmt.Println(str) // \u0026quot;[1 2 3]\u0026quot; Fmt 备忘单 顶级 fmt 格式化技巧\n"},{"url":"/post/2020/03/crypto-rand-int/","title":"Golang 中 crypto/rand（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/crypto-rand-int/\n Go 有两个用于随机数的包：\n math/rand 实现了大量伪随机数生成器。 crypto/rand 实现了具有受限接口的加密安全伪随机数生成器。  这两个包可以通过调用包 math/rand 中的 rand.New 与一个从 crypto/rand 获取数据的源来合并。\nimport ( crand \u0026#34;crypto/rand\u0026#34; rand \u0026#34;math/rand\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { var src cryptoSource rnd := rand.New(src) fmt.Println(rnd.Intn(1000)) // a truly random number 0 to 999 } type cryptoSource struct{} func (s cryptoSource) Seed(seed int64) {} func (s cryptoSource) Int63() int64 { return int64(s.Uint64() \u0026amp; ^uint64(1\u0026lt;\u0026lt;63)) } func (s cryptoSource) Uint64() (v uint64) { err := binary.Read(crand.Reader, binary.BigEndian, \u0026amp;v) if err != nil { log.Fatal(err) } return v }  警告：如果系统底层调用失败，则 crand.Reader 调用将返回错误。例如，如果它在 Unix 系统上不能读取 /dev/urandom，或者在 Windows 系统上 CryptAcquireContext 调用失败。\n "},{"url":"/post/2020/03/generate-uuid-guid/","title":"Golang 中生成唯一的字符串（UUID，GUID）(译文)","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/generate-uuid-guid/\n 通用唯一标识符 UUID（universally unique identifier）或全局唯一标识符 GUID （globally unique identifier）是用于标识信息的 128 位数字。\n UUID 是唯一的(出于实用目的)：它重复的概率非常接近零。 UUID 不依赖中央机构的注册和分配。  UUID 的字符串表示形式由 32 个十六进制数字组成，以 5 个组显示，由连字符 - 分隔。例如：\n123e4567-e89b-12d3-a456-426655440000 UUID 生成器示例 您可以使用来自 crypto/rand 包的 rand.Read 函数来生成基本的 UUID。\nb := make([]byte, 16) _, err := rand.Read(b) if err != nil { log.Fatal(err) } uuid := fmt.Sprintf(\u0026#34;%x-%x-%x-%x-%x\u0026#34;, b[0:4], b[4:6], b[6:8], b[8:10], b[10:]) fmt.Println(uuid) 输出：\n9438167c-9493-4993-fd48-950b27aad7c9 局限性 此 UUID 不符合 RFC4122。特别是，它不包含任何版本号或变体号。\n 警告：如果系统底层调用失败，则 rand.Read 调用将返回错误。例如，如果它在 Unix 系统上不能读取 /dev/urandom，或者在 Windows 系统上 CryptAcquireContext 调用失败。\n 延伸阅读 Golang 中生成随机数，字符和切片元素（译文）\n"},{"url":"/post/2020/03/rent-refund/","title":"软件公寓疫情退租指北","content":" 自 2020 年 3 月 12 日收到通知，免收 2020 年 2 月 1 日 —— 2020 年 4 月 30 日 期间三个月的租金，实际减免租金标准按租赁协议为准，主申请人于 3 月 12 日起，到小区物业前台核验身份证并签字，确认。\n 在实际操作过程中有些小麻烦，不过都克服了，我把它们记录下来，方便大家少踩坑。\n物业上班时间 早： 8:30 —— 12:00\n下午：13:30 —— 17:00\n准备材料  身份证原件及复印件（多打印几份，备用） 银行卡原件及复印件（多打印几份，备用）  注意: 银行卡需要提前获取对应的开户行信息，到时物业会要求你填写，不清楚的就打对应银行的客户电话（我因为没有提前准备在那耽搁了很长时间）\n 最近一个季度的收据，也就是对应免租期间的收据。  注意：如果找不到收据，也没有关系，准备好一份声明，这份声明写在身份证复印件的背面（这里我又踩了一个坑，誊写时由于时早上排队时写的，比较潦草，人家拒绝接受，另外尽量保持字迹工整，不能有修改，写的时候细心一点），下面是声明的内容。(下图有个信息是错误的，地址不对，应该是软件公寓 A 区，不是 D 区) 其他  即使减免租金了，物业费少不了，到时需要缴纳物业费； 去年 3 月份签订了再延期一年的同志们，即使不要求退款，4 月 30 日之前必须退房，无法延期； 周末办理这个手续的人比较多，大家看好自己的时间，我排队大概花了 40 分钟才轮到我 退租金相关资料  退房相关手续相关资料   "},{"url":"/post/2020/03/2019-march/","title":"那些年，一起杀草莓的日子","content":"去年的三月份，算是踏入初春，天气微热，百花盛开，正是踏青的好时节。我们一起去“杀”草莓。\nFirst blood Double kill Legendary Lovey dovey "},{"url":"/post/2020/03/generate-number-random-range/","title":"Golang 中生成随机数，字符和切片元素（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/generate-number-random-range/\n Go 伪随机数基础知识 使用包 math/rand 中的 rand.Seed 和 rand.Int63 函数生成 int64 类型的非负伪随机数：\nrand.Seed(time.Now().UnixNano()) n := rand.Int63() // for example 4601851300195147788 同样，rand.Float64 生成伪随机浮点数 x，其中 0 ≤ x \u0026lt; 1：\nx := rand.Float64() // for example 0.49893371771268225  警告：如果不先调用 rand.Seed，则每次运行该程序时，都会得到相同的数字序列。\n 请参阅随机数生成器中的种子是什么?, 解释伪随机数生成器的原理。\n几个随机源 math/rand 包中的函数全部使用单个随机源。\n如果需要，您可以使用自己的源创建一个新的 Rand 类型的随机生成器，然后使用其方法生成随机数：\ngenerator := rand.New(rand.NewSource(time.Now().UnixNano())) n := generator.Int63() x := generator.Float64() 给定范围内的整数和字符 a 和 b 之间的数字 使用 rand.Intn(m)，它返回一个伪随机数 n，其中 0 ≤ n \u0026lt; m。\nn := a + rand.Intn(b-a+1) // a ≤ n ≤ b \u0026lsquo;a\u0026rsquo; 和 \u0026lsquo;z\u0026rsquo; 之间的字符 c := \u0026#39;a\u0026#39; + rune(rand.Intn(\u0026#39;z\u0026#39;-\u0026#39;a\u0026#39;+1)) // \u0026#39;a\u0026#39; ≤ c ≤ \u0026#39;z\u0026#39; 切片中的随机元素 要从任意集合生成字符，请从字符切片中选择一个随机索引：\nchars := []rune(\u0026#34;AB⌘\u0026#34;) c := chars[rand.Intn(len(chars))] // for example \u0026#39;⌘\u0026#39; 延伸阅读 Runes 和字符编码（译文）\n"},{"url":"/post/2020/03/generate-random-string/","title":"Golang 中生成密码（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/generate-random-string/\n 随机字符串 该代码从瑞典语字母（包括非 ASCII 字符 å， ä 和 ö ）中生成一个随机的数字和字符字符串。\nrand.Seed(time.Now().UnixNano()) chars := []rune(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ\u0026#34; + \u0026#34;abcdefghijklmnopqrstuvwxyzåäö\u0026#34; + \u0026#34;0123456789\u0026#34;) length := 8 var b strings.Builder for i := 0; i \u0026lt; length; i++ { b.WriteRune(chars[rand.Intn(len(chars))]) } str := b.String() // E.g. \u0026#34;ExcbsVQs\u0026#34;  警告：要生成密码，应使用加密安全的伪随机数。请参阅 User-friendly access to crypto/rand。\n 有限制的随机字符串 此代码生成一个随机的 ASCII 字符串，该字符串至少包含一个数字和一个特殊字符。\nrand.Seed(time.Now().UnixNano()) digits := \u0026#34;0123456789\u0026#34; specials := \u0026#34;~=+%^*/()[]{}/!@#$?|\u0026#34; all := \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; + \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; + digits + specials length := 8 buf := make([]byte, length) buf[0] = digits[rand.Intn(len(digits))] buf[1] = specials[rand.Intn(len(specials))] for i := 2; i \u0026lt; length; i++ { buf[i] = all[rand.Intn(len(all))] } rand.Shuffle(len(buf), func(i, j int) { buf[i], buf[j] = buf[j], buf[i] }) str := string(buf) // E.g. \u0026#34;3i[g0|)z\u0026#34; Go 1.10 之前 在 Go 1.10 之前的代码中，用以下代码替换对rand.Shuffle的调用：\nfor i := len(buf) - 1; i \u0026gt; 0; i-- { // Fisher–Yates shuffle  j := rand.Intn(i + 1) buf[i], buf[j] = buf[j], buf[i] } 延伸阅读 Golang 中生成随机数，字符和切片元素（译文）\n"},{"url":"/post/2020/03/convert-int-to-string/","title":"Golang 中 int，int64 和字符串互转（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/convert-int-to-string/\n int/int64 转字符串 使用 strconv.Itoa 将 int 转换为十进制字符串。\ns := strconv.Itoa(97) // s == \u0026quot;97\u0026quot;  警告：在普通转换中，该值将解释为 Unicode 码位，并且生成的字符串将包含该码位表示的字符，并以 UTF-8 编码。\ns := string(97) // s == \u0026quot;a\u0026quot;\n 使用 strconv.FormatInt 以给定的进制数（十进制、十六进制）格式化 int64。\nvar n int64 = 97 s := strconv.FormatInt(n, 10) // s == \u0026quot;97\u0026quot; (十进制) var n int64 = 97 s := strconv.FormatInt(n, 16) // s == \u0026quot;61\u0026quot; (十六进制) 字符串转 int/int64 使用 strconv.Atoi 将十进制字符串解析为 int 。\ns := \u0026quot;97\u0026quot; if n, err := strconv.Atoi(s); err == nil { fmt.Println(n+1) } else { fmt.Println(s, \u0026quot;is not an integer.\u0026quot;) } // Output: 98 使用 strconv.ParseInt 解析一个十进制字符串（以10为基数），并检查其是否适合 int64。\ns := \u0026quot;97\u0026quot; n, err := strconv.ParseInt(s, 10, 64) if err == nil { fmt.Printf(\u0026quot;%d of type %T\u0026quot;, n, n) } // Output: 97 of type int64 func ParseInt(s string, base int, bitSize int) (i int64, err error) 两个数字参数表示一个基数（0、2 到 36）和一个占位大小（0 到 64）。\n如果第一个参数为 0，则字符串的前缀隐含基数：0b的基数为 2，0 或 0o 的基数是 8，0x 的基数为 16，否则为 10。\n第二个参数指定结果必须适合的整数类型。占位大小 0、8、16、32 和 64 对应于 int，int8，int16，int32 和 int64。\nint 和 int64 互转 一个 int 的大小是基于操作系统特定实现的，它可能是 32 位，也可能是 64 位，因此从 int 转换为 int64 时，您不会丢失任何信息。\nvar n int = 97 m := int64(n) // safe  但是，当转换为较短的整数类型时，该值将被截断以适合结果类型的大小。\n var m int64 = 2 \u0026lt;\u0026lt; 32 n := int(m) // truncated on machines with 32-bit ints fmt.Println(n) // either 0 or 4,294,967,296  有关计算 int 大小的代码，请参见 Maximum value of an int。 最佳实践 Pick the right one: int vs. int64。  通用格式化（宽度，缩进，符号） fmt.Sprintf 函数是将数据转换为字符串的好用工具：\ns := fmt.Sprintf(\u0026quot;%+8d\u0026quot;, 97) // s == \u0026quot; +97\u0026quot; (width 8, right justify, always show sign) "},{"url":"/post/2020/03/convert-string-to-float/","title":"Golang 中字符串和浮点数互转（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/convert-string-to-float/\n 字符串转为浮点数 使用 strconv.ParseFloat 函数将字符串解析为浮点数, 通过指定参数 bitSize 的值来确定精度：float32 为 32，float64 为 64。\nfunc ParseFloat(s string, bitSize int) (float64, error) 当 bitSize 为 32 时，结果仍为 float64 类型，但可以将其转换为 float32 而无需更改其值。\nf := \u0026quot;3.14159265\u0026quot; if s, err := strconv.ParseFloat(f, 32); err == nil { fmt.Println(s) // 3.1415927410125732 } if s, err := strconv.ParseFloat(f, 64); err == nil { fmt.Println(s) // 3.14159265 } 浮点数转为字符串 使用 fmt.Sprintf 方法将浮点数格式化为字符串。\ns := fmt.Sprintf(\u0026quot;%f\u0026quot;, 123.456) // s == \u0026quot;123.456000\u0026quot;    格式化输出 说明 占位符     1.234560e+02 科学计数法 %e   123.456000 有小数点而无指数 %f   123.46 默认宽度，精度 2 %.2f   ␣␣123.46 宽度 8, 精度 2 %8.2f   123.456 (根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出) %g    Fmt 备忘单 How to format with fmt\n"},{"url":"/post/2020/03/convert-string-to-byte-slice/","title":"Golang 中字节切片/数组和字符串互转（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/convert-string-to-byte-slice/\n 基本认知 在字符串和字节切片（数组）之间进行转换时，会得到一个全新的切片，其中包含与字符串相同的字节，反之亦然。\n 转换不会修改数据 唯一的区别是字符串是不可变的，而字节片可以修改   如果需要操纵字符串的 rune ，则可能需要将字符串转换为 rune 切片，更多细节请看这篇文章 Golang 中 runes 和 字符串互转（译文）\n 将字符串转为字节切片 将字符串转换为字节切片时，会得到一个新的切片，其中包含与字符串相同的字节。\nb := []byte(\u0026quot;ABC€\u0026quot;) fmt.Println(b) // [65 66 67 226 130 172] 请注意，字符 € 是使用 3 个字节的 UTF-8 编码的。有关 Unicode 码位的 UTF-8 编码的更多信息，请参阅关于 rune 的这篇文章。\n将字节切片转为字符串 当您将字节的一部分转换为字符串时，您将获得一个新的字符串，其中包含与该片段相同的字节。\ns := string([]byte{65, 66, 67, 226, 130, 172}) fmt.Println(s) // ABC€ 性能 这些转换将创建一个新的切片或字符串，因此时间复杂度与处理的字节数成正比。\n"},{"url":"/post/2020/03/convert-string-to-rune-slice/","title":"Golang 中 runes 和 字符串互转（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/convert-string-to-rune-slice/\n Convert string to runes  将字符串转换为 rune 切片时，会得到一个新的切片，其中包含字符串的 Unicode 码位( runes ) 对于无效的 UTF-8 序列，每个无效字节的 rune 值将为 0xFFFD。  r := []rune(\u0026quot;ABC€\u0026quot;) fmt.Println(r) // [65 66 67 8364] fmt.Printf(\u0026quot;%U\\n\u0026quot;, r) // [U+0041 U+0042 U+0043 U+20AC]  您还可以使用 range 循环访问字符串的码位。\n Convert runes to string  当您将一小段 runes 转换为字符串时，会得到一个新字符串，该字符串是将 runes 转换为 UTF-8 编码字符串的串联。 有效 Unicode 码位范围之外的值将转换为 Unicode 替换字符\\uFFFD, 显示为�。  s := string([]rune{'\\u0041', '\\u0042', '\\u0043', '\\u20AC', -1}) fmt.Println(s) // ABC€� 性能 这些转换将创建一个新的切片或字符串，因此时间复杂度与处理的字节数成正比。\n"},{"url":"/post/2020/03/rune/","title":"Runes 和字符编码（译文）","content":" 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/rune\n 字符，ASCII 和 Unicode rune 类型是 int32 的别名，用于强调其代表的是码位（code point），而不是整数。\nASCII 定义 128 个字符，由码位 0 – 127 标识。它涵盖英文字母，拉丁数字和其他一些字符。\nUnicode 是 ASCII 的超集，它定义了 1,114,112 个代码点的代码空间。 Unicode 版本 10.0 涵盖 139 个现代和历史文本集（包括符文字母，但不包括 Klingon ）以及多个符号集。\n字符串和 UTF-8 编码  字符串是字节序列，而不是符文。\n 但是，字符串通常包含以 UTF-8 编码的 Unicode 文本，该文本使用一到四个字节对所有 Unicode 码位进行编码。（ASCII 字符使用一个字节编码，而其他码位则使用更多字节。）\n由于 Go 源代码本身被编码为 UTF-8，因此字符串文字将自动获得此编码。\n例如，在字符串\u0026quot;café\u0026quot;中，字符é（码位 233）使用两个字节编码，而 ASCII 字符 c，a 和 f（码位 99、97 和 102）仅使用一个字节：\nfmt.Println([]byte(\u0026quot;café\u0026quot;)) // [99 97 102 195 169] fmt.Println([]rune(\u0026quot;café\u0026quot;)) // [99 97 102 233] "},{"url":"/post/2020/03/type-assertion-switch/","title":"Golang 中类型断言和类型切换（译文）","content":"类型断言提供对接口具体值的访问。\n 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/type-assertion-switch/\n 类型断言 类型断言并不能真正将 interface 转换为另一种数据类型，但是可以访问 interface 的具体值，而这正是您所希望的。\n类型断言 x.(T) 断言 x 中存储的具体值是 T 类型，并且 x 不为 nil\n 如果 T 不是 interface，则断言 x 的动态类型与 T 相同 如果 T 是 interface，则断言 x 的动态类型实现了 T  var x interface{} = \u0026quot;foo\u0026quot; var s string = x.(string) fmt.Println(s) // \u0026quot;foo\u0026quot; s, ok := x.(string) fmt.Println(s, ok) // \u0026quot;foo true\u0026quot; n, ok := x.(int) fmt.Println(n, ok) // \u0026quot;0 false\u0026quot; n = x.(int) // ILLEGAL 输出：\npanic: interface conversion: interface {} is string, not int 类型切换 类型切换顺序执行多个类型声明，并使用匹配的类型运行第一种情况。\nvar x interface{} = \u0026quot;foo\u0026quot; switch v := x.(type) { case nil: fmt.Println(\u0026quot;x is nil\u0026quot;) // here v has type interface{} case int: fmt.Println(\u0026quot;x is\u0026quot;, v) // here v has type int case bool, string: fmt.Println(\u0026quot;x is bool or string\u0026quot;) // here v has type interface{} default: fmt.Println(\u0026quot;type unknown\u0026quot;) // here v has type interface{} } 输出：\nx is bool or string "},{"url":"/post/2020/03/go-json/","title":"如何在 Go 中使用 JSON【最佳实践】（译文）","content":"JSON 数据交换格式对人类来说很容易读写，对机器进行解析和生成也非常有效。\n 作者：Stefan Nilsson\n原文网址：https://yourbasic.org/golang/json-example/\n 默认类型 用于解码和编码 JSON 的默认 Go 类型是\n   Go JSON     bool booleans   float64 numbers   string strings   nil null    另外，可以将 math.big 包中的 time.Time 和数字类型自动编码为JSON字符串。\n请注意，JSON不支持基本整数类型。它们通常可以用浮点数来近似。\n 由于实现 IEEE 754-2008 binary64（双精度）数字的软件普遍可用并得到广泛使用，因此，期望其精度或范围不超过其提供的精度的实现可以实现良好的互操作性。\n请注意，使用此类软件时，在实现将完全一致于其数值的意义上，整数（整数）且在 $\\ce{[-2^53 + 1, 2^53 - 1]}$ 范围内是可以互操作的。\nRFC 7159: JSON数据交换格式\n 编码(marshal) struct 转 JSON 包 encoding/json 中的 json.Marshal 函数生成JSON数据。\ntype FruitBasket struct { Name string Fruit []string Id int64 `json:\u0026quot;ref\u0026quot;` private string // 私有字段不会被编码 Created time.Time } basket := FruitBasket{ Name: \u0026quot;Standard\u0026quot;, Fruit: []string{\u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Orange\u0026quot;}, Id: 999, private: \u0026quot;Second-rate\u0026quot;, Created: time.Now(), } var jsonData []byte jsonData, err := json.Marshal(basket) if err != nil { log.Println(err) } fmt.Println(string(jsonData)) 输出：\n{\u0026quot;Name\u0026quot;:\u0026quot;Standard\u0026quot;,\u0026quot;Fruit\u0026quot;:[\u0026quot;Apple\u0026quot;,\u0026quot;Banana\u0026quot;,\u0026quot;Orange\u0026quot;],\u0026quot;ref\u0026quot;:999,\u0026quot;Created\u0026quot;:\u0026quot;2018-04-09T23:00:00Z\u0026quot;} 只有可以表示为JSON的数据才会被编码；有关完整规则，请参阅 json.Marshal。\n 一个结构体中，只有可导出(公有)的字段可以在 JSON 中输出。其他字段将被忽略。 具有json标签的字段：结构体中声明的字段以其标签后名称存储, 而不是其变量名称。 指针将被编码为它们指向的值，如果指针为nil，则值为null。  漂亮的输出(格式化输出) 在上面的示例中，将 json.Marshal 替换为 json.MarshalIndent 以缩进JSON输出。\njsonData, err := json.MarshalIndent(basket, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) 输出：\n{ \u0026quot;Name\u0026quot;: \u0026quot;Standard\u0026quot;, \u0026quot;Fruit\u0026quot;: [ \u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Orange\u0026quot; ], \u0026quot;ref\u0026quot;: 999, \u0026quot;Created\u0026quot;: \u0026quot;2018-04-09T23:00:00Z\u0026quot; } 解码(unmarshal) JSON 转 struct 包 encoding/json 中的 json.Unmarshal函数解析JSON数据。\ntype FruitBasket struct { Name string Fruit []string Id int64 `json:\u0026quot;ref\u0026quot;` Created time.Time } jsonData := []byte(` { \u0026quot;Name\u0026quot;: \u0026quot;Standard\u0026quot;, \u0026quot;Fruit\u0026quot;: [ \u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Orange\u0026quot; ], \u0026quot;ref\u0026quot;: 999, \u0026quot;Created\u0026quot;: \u0026quot;2018-04-09T23:00:00Z\u0026quot; }`) var basket FruitBasket err := json.Unmarshal(jsonData, \u0026amp;basket) if err != nil { log.Println(err)Todo } fmt.Println(basket.Name, basket.Fruit, basket.Id) fmt.Println(basket.Created) 输出：\nStandard [Apple Banana Orange] 999 2018-04-09 23:00:00 +0000 UTC 请注意，Unmarshal自行分配了一个新的切片。这就是切片, Map 和指针的解码工作的方式。\n对于给定的 JSON 键名 Foo，Unmarshal将尝试按以下顺序匹配结构体中的字段：\n 结构体中具有标签json：\u0026quot;Foo\u0026quot;的可导出（公有）字段 结构体中命名为 Foo 的字段 一个名为 FOO，FoO 或其他不区分大小写的匹配项的可导出（公有）字段  只有在目标类型中找到的字段才会被解码：\n 当您只希望选择几个特定字段时，这很有用。 特别是，目标结构中任何未导出（私有）的字段都不会受到影响。  任意对象和数组 encoding/json 包使用\n map[string]interface{} 以存储任意 JSON 对象 []interface {} 用于存储任意 JSON 数组  它将把任何有效的 JSON 数据解析到 interface{} 值中\n考虑以下 JSON 数据：\n{ \u0026quot;Name\u0026quot;: \u0026quot;Eve\u0026quot;, \u0026quot;Age\u0026quot;: 6, \u0026quot;Parents\u0026quot;: [ \u0026quot;Alice\u0026quot;, \u0026quot;Bob\u0026quot; ] } json.Unmarshal 函数会将其解析为一个映射，该映射的键为字符串，其值本身存储为空接口值：\nmap[string]interface{}{ \u0026quot;Name\u0026quot;: \u0026quot;Eve\u0026quot;, \u0026quot;Age\u0026quot;: 6.0, \u0026quot;Parents\u0026quot;: []interface{}{ \u0026quot;Alice\u0026quot;, \u0026quot;Bob\u0026quot;, }, } 我们可以使用 range 语句遍历 Map，并使用类型转换访问其值。\njsonData := []byte(`{\u0026quot;Name\u0026quot;:\u0026quot;Eve\u0026quot;,\u0026quot;Age\u0026quot;:6,\u0026quot;Parents\u0026quot;:[\u0026quot;Alice\u0026quot;,\u0026quot;Bob\u0026quot;]}`) var v interface{} json.Unmarshal(jsonData, \u0026amp;v) data := v.(map[string]interface{}) for k, v := range data { switch v := v.(type) { case string: fmt.Println(k, v, \u0026quot;(string)\u0026quot;) case float64: fmt.Println(k, v, \u0026quot;(float64)\u0026quot;) case []interface{}: fmt.Println(k, \u0026quot;(array):\u0026quot;) for i, u := range v { fmt.Println(\u0026quot; \u0026quot;, i, u) } default: fmt.Println(k, v, \u0026quot;(unknown)\u0026quot;) } } 输出：\nName Eve (string) Age 6 (float64) Parents (array): 0 Alice 1 Bob JSON 文件示例 包 encoding/json 中的 json.Decoder 和 json.Encoder 类型支持读取和写入流，例如文件，JSON数据。\n代码演示如下功能：\n 从 Reader（strings.Reader）读取 JSON 对象流 从每个对象中移除字段 Age 然后将对象写入 Writer（os.Stdout）  const jsonData = ` {\u0026quot;Name\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;Age\u0026quot;: 25} {\u0026quot;Name\u0026quot;: \u0026quot;Bob\u0026quot;, \u0026quot;Age\u0026quot;: 22} ` reader := strings.NewReader(jsonData) writer := os.Stdout dec := json.NewDecoder(reader) enc := json.NewEncoder(writer) for { // 读取一个 JSON 对象, 并把它存入 Map 类型中 var m map[string]interface{} if err := dec.Decode(\u0026amp;m); err == io.EOF { break } else if err != nil { log.Fatal(err) } // 移除所有键值对中键名为 Age 的数据 for k := range m { if k == \u0026quot;Age\u0026quot; { delete(m, k) } } // 将 Map 数据写为 JSON 对象 if err := enc.Encode(\u0026amp;m); err != nil { log.Println(err) } } 输出：\n{\u0026quot;Name\u0026quot;:\u0026quot;Alice\u0026quot;} {\u0026quot;Name\u0026quot;:\u0026quot;Bob\u0026quot;} "},{"url":"/post/2019/08/cpluspuls14-required/","title":"Microsoft Visual C++ 14.0 is required","content":" 在Windows系统上安装某些需要编译的包时经常会遇到这个问题，经常使用的办法是找一个编译好的版本直接通过pip安装，但是找不到怎么办?\n 省时省力，第一优先级 Python Extension Packages for Windows: https://www.lfd.uci.edu/~gohlke/pythonlibs/\n安装C编译环境 失败经历 先附上我的失败经历，希望直接看到成功的，直接下拉到最后。\n1. 利用python包的错误提示信息 Microsoft Visual C++ 14.0 is required. Get it with \u0026quot;Microsoft Visual C++ Build Tools\u0026quot;: https://visualstudio.microsoft.com/downloads/ 这个网站把2015、2017版本给隐藏起来，找起来比较麻烦。 看这里所有的旧版本都在这: https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/ 2. python版本和对应的C++编译版本 https://wiki.python.org/moin/WindowsCompilers\n   Visual C++ CPython     14.X 3.5, 3.6, 3.7, 3.8   10.0 3.3, 3.4   9.0 2.6, 2.7, 3.0, 3.1, 3.2    3. 我把2019, 2017, 2015版本(均高于14.0版本)都安装一遍后仍然不行 成功经历 参考博客 https://www.hongweipeng.com/index.php/archives/1532/\n资源下载链接: https://pan.baidu.com/s/19CkNu5ZiifNrYNHj77tbCg\n提取码: ggdv\n默认安装2015，注意根据您的操作系统选择Windows 8.1 / 10 SDK。这个时间比较长，耐心等到安装结束之后，再重试安装，我这边成功了，那么你呢？ 如果有更好的方案，请在下方留言，感激不尽。\n"},{"url":"/post/2019/07/change-redis-password/","title":"Change Redis Password","content":"Ubuntu 修改配置文件 /etc/redis/redis.conf requirepass 你的密码 重启 redis 服务 service redis restart Win10 修改配置文件 C:\\Program Files\\Redis\\redis.windows-service.conf requirepass 你的密码 重启 redis 服务 net stop redis net start redis 注: 这两个操作都需要以管理员身份权限\n实时生效(免重启) 启动 redis 客户端 redis-cli 127.0.0.1:6379\u0026gt; config set requirepass 你的密码 注: 这种方式确实是实时生效，但是一旦重启后，这种配置就丢失了，以配置文件为准, 因为它并没有被持久化到文件中。\n参考文档  set a password for redis 莫博客  "},{"url":"/post/2019/07/change-mysql-password/","title":"Change Mysql Password","content":" 去年的这个夏天，不像今年雨水很多，天气微热，朋友打电话过来说: “他的数据库被人黑了，对方扬言必须给某某账号下转xxx比特币，不然就删库”。修改数据库密码有三种常见方式：mysqladmin和sql。\n 修改数据库密码前，我们先来看下数据库里存储的用户和密码信息，此处示例中我使用的密码是666, 要修改为999。\nmysql\u0026gt; select host,user,password from mysql.user where user=\u0026quot;root\u0026quot;; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | hugo | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | 127.0.0.1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | ::1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | % | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | +-----------+------+-------------------------------------------+ 5 rows in set (0.00 sec) 方式一 mysqladmin -uroot -p666 flush-privileges password \u0026quot;999\u0026quot; 可以通过下面的方式来验证：\nroot@hugo:~# mysqladmin -uroot -p999 ping mysqld is alive 修改成功\nmysql\u0026gt; select host,user,password from mysql.user where user=\u0026quot;root\u0026quot;; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | | hugo | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | 127.0.0.1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | ::1 | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | | % | root | *007D50CA06F69776D307B1BEC71CD73D0EA0999C | +-----------+------+-------------------------------------------+ 5 rows in set (0.00 sec) 这种方式因为没有指定-h参数，所以默认修改了host=localhost的那一行, 并不彻底。\n方式二 mysql -uroot -p666 -e 'UPDATE mysql.user SET Password=PASSWORD('999') where user=\u0026quot;root\u0026quot;;flush privileges;' 同样我们来看下是否修改成功？\nroot@hugo:~# mysqladmin -uroot -p999 ping mysqld is alive 没毛病, 修改成功\nmysql\u0026gt; select host,user,password from mysql.user where user=\u0026quot;root\u0026quot;; +-----------+------+-------------------------------------------+ | host | user | password | +-----------+------+-------------------------------------------+ | localhost | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | | hugo | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | | 127.0.0.1 | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | | ::1 | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | | % | root | *627B3E4116939F447D767EECFB048F52DFBF73A7 | +-----------+------+-------------------------------------------+ 5 rows in set (0.00 sec) 很明显，这种方式更加彻底，因为是通过sql的方式。\n方式三 有时候我们并不知道原密码，怎么办呢？\n参照网友给的方法:\n以安全模式启动mysql，可以直接以root身份登录，然后重设密码。下面是具体步骤(版本5.7.X)\n停掉在运行的MySQL服务：\nsudo service mysql stop 以安全模式启动mysql：\nsudo mysqld_safe --skip-grant-tables --skip-networking \u0026amp; 直接用root登录，无需密码：\nmysql -uroot 重设密码：\nmysql\u0026gt; use mysql; mysql\u0026gt; update user set authentication_string=password('password') where user='root'; mysql\u0026gt; flush privileges; 退出mysql\nmysql \u0026gt; quit 重启mysql\nsudo service mysql restart "},{"url":"/post/2019/07/history-and-history-file/","title":"Difference Between The 'history' Command and 'cat ~/.bash_history'","content":" 寻找这个问题的答案时，无意间看到1999年的一段对话，完美的解释了我的疑问。通过操作验证，David 说的 100% 正确。 如果别人问起我这个问题，我也会以他的原话来回答，因为我找不到比他回答得更完美的答案了。\nHistory for your current shell is retained in RAM. It is appended to .bash_history (subject to the length you define for that file) when you exit the shell. Therefore, cat ~/.bash_history will always be as current as the LAST shell you ran, and its last entry should be \u0026ldquo;exit\u0026rdquo;.\nCommands run in the current shell won\u0026rsquo;t appear there yet.\n History for your current shell is retained in RAM. 终端(shell)的操作历史保存在内存(Random Access Memory)中。\n并且只有当前终端可以看到。与此同时，你再打开一个终端，是看不到前一个的操作记录，除非在你打开第二个终端前，第一个打开的终端已经关闭了。 It is appended to .bash_history (subject to the length you define for that file) when you exit the shell. 当退出终端时，操作历史才会被添加到.bash_history文件中，.bash_history中存储的记录数量取决于你定义的值(HISTFILESIZE)。\n这里顺便解释一个问题：HISTFILESIZE 和 HISTSIZE 的差别？ 在linux系统中，history命令可以输出历史命令，历史命令默认保存在文件`.bash_history`中。 HISTFILESIZE 定义了在 .bash_history 中保存命令的记录总数，可以理解为.bash_history文件中最多只有 HISTFILESIZE 行 HISTSIZE 定义了 history 命令输出的记录数，即输出 .bash_history 文件中的最后 HISTSIZE 行 Therefore, cat ~/.bash_history will always be as current as the LAST shell you ran, and its last entry should be \u0026ldquo;exit\u0026rdquo;. 所以查看文件.bash_history内容时，看到的总是最近一次终端运行的命令，并且它的最后一条命令是exit。\nCommands run in the current shell won\u0026rsquo;t appear there yet. 当前终端中运行过的命令还不会出现在这个文件.bash_history中。\n"},{"url":"/post/2019/07/history-usage/","title":"History Usage","content":" history 命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。\n  该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入 !2。\n  历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。\n 语法 history(选项)(参数) 选项 -c：清空当前历史命令； -a：将历史命令缓冲区中命令写入历史命令文件中； -r：将历史命令文件中的命令读入当前历史命令缓冲区； -w：将当前历史命令缓冲区命令写入历史命令文件中。 参数 n：打印最近的n条历史命令。 实例 使用history命令显示最近使用的10条历史命令，输入如下命令：\n[root@localhost ~]# history 10 92 ls 93 cd .. 94 ls 95 exit 96 ls -a 97 cd .ssh/ 98 ls 99 cat known_hosts 100 exit 101 history 10 其他特殊技巧 使用 HISTTIMEFORMAT 显示时间戳 export HISTTIMEFORMAT='%F %T ' 注意：这个功能只能用在当 HISTTIMEFORMAT 这个环境变量被设置之后，之后的那些新执行的 bash 命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置 HISTTIMEFORMAT 变量的时间。可以在 .bash_profile 中把这条设置指令添加进去，后面就可以一直使用了。\n使用 Ctrl + R 查询历史记录 动手试试，超级便利。\n更多关于history和.bash_history的内幕可以看下我整理的这篇博客 "},{"url":"/post/2019/07/tar-zip-summary/","title":"Tar压缩命令小结","content":" 今天遇到一个麻烦，从生产环境备份的一个SQL脚本，体积是705M，希望下载到本地做测试，由于网络不稳定、带宽有限等问题，无法下载成功，于是怎么办？压缩！\n root@localhost:/home/test# ls -lh total 705M -rw-r--r-- 1 root root 705M 7月 2 09:48 bf_2019_07-02.sql 我们先来回顾下压缩/解压缩相关常用命令\nTar  -c create 简写, 创建压缩 -x extract 简写, 提取压缩 -f 生成的文件名 -z 以gzip方式压缩 -j 以bzip2方式压缩 -J 以xz方式压缩 -t list 简写, 列出压缩的内容 -v verbose 简写, 详细列出已处理的文件  示例  Tar 压缩  tar -czf a.tar.gz a.sql tar -cjf a.tar.bz2 a.sql tar -cJf a.tar.xz a.sql  Tar 解压缩  tar -xzf a.tar.gz tar -xjf a.tar.bz2 tar -xJf a.tar.xz  Tar 解压指定文件   查找指定文件是否存在  tar -ztvf a.tar.gz | grep \u0026quot;keyword\u0026quot; 解压时增加完整文件名(含路径)  tar -zxvf a.tar.gz a/keyword 压缩算法效率对比 root@localhost:/home/test# time tar czf backup.tar.gz bf_2019_07-02.sql real 0m36.603s user 0m35.226s sys 0m4.191s root@localhost:/home/test# time tar cjf backup.tar.bz2 bf_2019_07-02.sql real 7m57.828s user 7m55.994s sys 0m4.707s root@localhost:/home/test# time tar cJf backup.tar.xz bf_2019_07-02.sql real 17m22.529s user 17m19.340s sys 0m24.694s root@localhost:/home/test# ls -lh total 875M -rw-r--r-- 1 root root 54M 7月 2 16:08 backup.tar.bz2 -rw-r--r-- 1 root root 69M 7月 2 15:59 backup.tar.gz -rw-r--r-- 1 root root 49M 7月 2 18:19 backup.tar.xz -rw-r--r-- 1 root root 705M 7月 2 09:48 bf_2019_07-02.sql    压缩方式 压缩耗时 压缩后大小(M)     gzip 36.603s 69   bz2 7m57.828s 54   xz 17m22.529s 49    总体来说: gzip性价比最高，bz2和xz可以把文件压得更小，但是耗时太长。\n问题小结 问题一：tar: Removing leading '/' from member names 原因: tar 在压缩文件时，默认会取相对路径，无法处理绝对路径，需要使用参数P来指定。 通过tar --help|grep leading，可以查到下面的提示信息：\n-P, --absolute-names don't strip leading '/'s from file names --strip-components=NUMBER strip NUMBER leading components from file 示例： tar czf target.tgz -P /a/b/source "},{"url":"/post/2019/07/export-mysql-table-to-excel/","title":"Export Mysql Table to Excel","content":" 今天有同事问我怎么把Mysql某个表中的数据导出到Excel中？本以为so easy的事，结果踩了很多坑，记录下。\n 方法一: 使用MySQL Workbench导出CSV MySQL Workbench 这个客户端软件是我一直使用的一款 MySQL 客户端, 超级强大。自然也少不了导入和导出的功能。具体导出的步骤请移步至官方文档(图文并茂, 美滴很)\n在准备享受胜利果实的时候，使用Excel打开导出的CSV文件，我去，中文全都是乱码，怎么办呢？\n甭捉急，两步搞定乱码问题:\n 使用记事本打开上述的CSV文件 文件 =\u0026gt; 另存为 =\u0026gt; 选中编码为ANSI =\u0026gt; 最后覆盖原文件，就好了  方法二: 使用原生SQL导出CSV 万变不离其宗，SQL 是一种更加原始粗暴的方案，但是更加实用，即使再花哨的工具，最后归根结底还是会回到这个位置。\n语法 SELECT * FROM 表名 INTO OUTFILE '输出的文件位置' FIELDS TERMINATED BY '字段分隔符(,)' ENCLOSED BY '字段包围符(\u0026quot;)' LINES TERMINATED BY '行间分隔符(\\n)'; 理想很丰满，现实很骨感。有了语法，执行时又遇到问题了。\n问题一: secure-file-priv选项问题 ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 使用的MySQL版本5.7会遇到--secure-file-priv这个选项问题，5.6不会。\n secure-file-priv 选项值解释     属性值 解释     NULL 限制mysqld不允许导入或导出   /tmp 限制mysqld只能在/tmp目录中执行导入导出，其他目录不能执行   无 不限制mysqld在任意目录的导入导出    通过show global variables like '%secure_file_priv%';查询到我的配置属于限定目录导出，于是导出时指定到那个目录下就好了。\n问题二: 没有表头 没有表头，工具类导出做了此项优化，一般不存在这个问题。\n/* Add column headers */ SELECT 'A', 'B', 'C' UNION ALL /* Now the actual query */ SELECT a, b, c FROM `TABLENAME` /* Save the query results to a file */ INTO OUTFILE '/tmp/orders.csv' FIELDS TERMINATED BY ',' ENCLOSED BY '\u0026quot;' LINES TERMINATED BY '\\n'; 怎么做到的呢？通过UNION ALL将自定义表头和结果集合并。\n反思 永远不要我以为，我以为的就是我以为的吗？\n"},{"url":"/post/2019/linux-shell-shortcut/","title":"Linux Shell Shortcut","content":" 作为一名键盘控，提升十倍效率的快捷键。\n Ctrl + U – 剪切光标前的内容 Ctrl + K – 剪切光标至行末的内容 Ctrl + Y – 粘贴 Ctrl + E – 移动光标到行末 (End) Ctrl + A – 移动光标到行首(Ahead) ALT + F – 跳向下一个空格 (Front) ALT + B – 跳回上一个空格 (Back) ALT + Backspace – 删除前一个单词 Ctrl + W – 剪切光标前一个单词 (Word) Ctrl + Insert – 复制 Shift + Insert – 粘贴 更多Linux常用快捷键及命令总结参见这里\n"},{"url":"/post/2019/chrome-startup-auto-redirect-hao123/","title":"无法将所做的改动保存到 chrome lnk","content":" 昨天把旧电脑取出来，给它充放电。恰巧要查点资料，顺手打开谷歌浏览器，我去，怎么一上来就是hao123？\n 我的第一反应就是某个软件改写了Chrome的设置。\n1. 查询设置 启动时  打开新标签页 从上次停下的地方继续 打开特定网页或一组网页  添加新网页 使用当前网页    没有任何异常，没有植入hao123网址\n2. 右键Chrome快捷方式查看属性 目标(T): \u0026quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\u0026quot; http://www.hao123.com 起始位置(S): \u0026quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\u0026quot; 果然罪魁祸首在这里，把后面的网址删除后，提示: 无法将所做的改动保存到 chrome lnk\n3. 解决方案  删除Chrome快捷方式 拷贝 起始位置(S) 到地址栏 找到 chrome.exe, 重新创建快捷方式  "},{"url":"/post/2019/extra-mac-address-using-python/","title":"Extracting MAC address using Python","content":" 使用 Python 来提取计算机的 MAC 地址。翻译来源: https://www.geeksforgeeks.org/extracting-mac-address-using-python/\n MAC地址也称为物理地址，是分配给计算机网卡(NIC)的唯一标识符。NIC有助于将计算机与网络中的其他计算机连接。 MAC地址对于所有NIC都是唯一的。\nMAC地址的用途：\n 在IP地址频繁更改的地方很有用。帮助网络管理员。获取有关网络流量的信息。 帮助我们配置哪些计算机可以连接到我们的计算机。通过这种方式我们可以过滤潜在的垃圾邮件/病毒攻击。 帮助从世界各地的其他计算机中唯一识别计算机。  Example MAC Address 00 16 2C 99 0B DB |______| |______| | | Vendor No Serial No 方法1：使用 uuid.getnode() getnode() 可用于提取计算机的MAC地址。该方法在uuid模块中定义。 下面给出的插图代码显示了如何使用uuid1（）函数为给定主机生成UUID，该UUID由其MAC地址标识。\n代码: ## Python Program to compute ## MAC address of host ## using UUID module import uuid ## printing the value of unique MAC ## address using uuid and getnode() function print(hex(uuid.getnode())) 输出: 0x163e990bdb 缺点:  显而易见的缺点是“输出不是格式化的形式”。  方法2：使用getnode() + format()[为了更好的格式化形式] 代码: ## Python 3 code to print MAC ## in formatted way. import uuid ## joins elements of getnode() after each 2 digits. print (\u0026quot;The MAC address in formatted way is : \u0026quot;, end=\u0026quot;\u0026quot;) print (':'.join(['{:02x}'.format((uuid.getnode() \u0026gt;\u0026gt; ele) \u0026amp; 0xff) for ele in range(0,8*6,8)][::-1])) 输出: The MAC address in formatted way is : 00:16:3e:99:0b:db 缺点:  该代码表现似乎很复杂。  方法3：使用getnode() + findall() + re()[为了降低复杂性] 代码: ## Python 3 code to print MAC ## in formatted way and easier ## to understand import re, uuid ## joins elements of getnode() after each 2 digits. ## using regex expression print (\u0026quot;The MAC address in formatted and less complex way is : \u0026quot;, end=\u0026quot;\u0026quot;) print (':'.join(re.findall('..', '%012x' % uuid.getnode()))) 输出: The MAC address in formatted and less complex way is : 00:16:3e:99:0b:db 方法4: 使用getnode() + for...range... 代码: ## Python 3 code to print MAC ## in formatted way and easier ## to understand import uuid ## joins elements of getnode() after each 2 digits. ## using slice expression print (\u0026quot;The MAC address in formatted and less complex way is : \u0026quot;, end=\u0026quot;\u0026quot;) mac = '%012x' % uuid.getnode() print(':'.join(mac[i:i+2] for i in range(0, len(mac), 2))) 输出: The MAC address in formatted and less complex way is : 00:16:3e:99:0b:db "},{"url":"/post/2019/replace-flash-disk/","title":"还在找U盘？别找了，我教你一招！","content":"最近有同事问我，有没有U盘，她要给别人拷下文件，或者是从别人那拷贝下文件。\n这些文件普遍有个特点就是体积大（超出微信客户端中的上限 100M）\n办公室里这种小事时常发生，时间就在指缝间悄悄流逝。\n作为一名 “懒人”，这种事要是发生在身上，我会这么解决：\n准备工作  发送方和接收方在一个局域网内 发送方的 PC 上有 python 环境  开始我的表演  以 Win10 系统演示，其他系统方法类似\n Step.1 发送方进入要传递文件的目录\nStep.2 地址栏输入cmd\nStep.3 输入指令ipconfig，获得ipv4地址，假设你获得的是192.168.1.10\nStep.4 确认系统环境的python版本，不同版本输入不同的指令，请对号入座。\n python2  python -m SimpleHTTPServer  python3  python -m http.server Step.5 此时防火墙会有提示，选择允许访问\nStep.6 接收方打开任意浏览器，输入http:192.168.1.10:8000，页面上立马会返回Step.1中看到的目录，此时就已经大功告成了。\n新的旅程 技术的诞生是因为问题需要得到解决，然而解决问题的方案永远不止一种，此时应在特定的场景下寻求最优解，不局限某种方法，不固步自封，勇于尝试各种思路。从这周开始，每一周的周末，我都会和大家分享，日常工作生活学习中遇到的各种问题，以及我是怎么解决的，不求给大家多大的帮助，但求拓宽解决问题的思路。\n"},{"url":"/post/2019/03/view-mem-info-in-win10/","title":"View Memory Information Using the Command Line in Win10","content":" 通过命令行查看内存条信息\n 步骤一: 打开命令行模式  方式一: Win + R 打开运行，输入cmd回车; 方式二: Win + S 打开搜索，输入cmd回车;  步骤二: 命令行模式下输入wmic C:\\Users\\Hugo\u0026gt;wmic wmic:root\\cli\u0026gt; 步骤三: 继续输入memorychip wmic:root\\cli\u0026gt;memorychip ... Capacity ConfiguredClockSpeed ConfiguredVoltage Manufacturer ... 8589934592 2133 1200 Kingston ... 8589934592 2133 1200 Samsung 一般购买内存条就关心上面几个参数: 容量, 频率, 电压，生产商；其余参数由于版面有限，这里就不再展示了。\n附录: 内存条参数说明    参数 描述     Capacity  获取内存容量（单位KB）   Caption  物理内存还虚拟内存   ConfiguredClockSpeed  配置时钟速度   ConfiguredVoltage  配置电压   CreationClassName  创建类名   DataWidth  获取内存带宽   Description  描述   DeviceLocator  获取设备定位器   FormFactor  构成因素   HotSwappable  是否支持热插拔   InstallDate  安装日期   InterleaveDataDepth  数据交错深度   InterleavePosition  交错的位置   Manufacturer  生产商   MaxVoltage  最大电压   MemoryType  内存类型   MinVoltage  最小电压   Model  型号   Name  名字   OtherIdentifyingInfo  其他识别信息   PartNumber  零件编号   PositionInRow  行位置   PoweredOn  是否接通电源   Removable  是否可拆卸   Replaceable  是否可更换   SerialNumber  编号   SKU  SKU号   SMBIOSMemoryType  SMBIOS内存类型   Speed  速率   Status  状态   Tag  唯一标识符的物理存储器   TotalWidth  总宽   TypeDetail  类型详细信息   Version  版本信息    "},{"url":"/post/2019/defer-panic-and-recover/","title":"Defer, Panic and Recover","content":" 翻译自 golang 的官方博客 Defer, Panic, and Recover\n Go 具有控制流程的常用机制：if，for，switch，goto。它还有 go 语句在单独的 goroutine 中运行代码。在这里，我想讨论一些不太常见的问题：defer, panic, recover。\ndefer 语句将函数调用推送到列表中。在周围函数返回后执行已保存调用的列表。延迟通常用于简化执行各种清理操作的功能。\n举个例子，让我们看一个打开两个文件并将一个文件的内容复制到另一个文件的函数：\nfunc CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } dst, err := os.Create(dstName) if err != nil { return } written, err = io.Copy(dst, src) dst.Close() src.Close() return } 这可以正常运行，但有一个 bug。 如果对 os.Create 的调用失败，该函数将返回而不关闭源文件。 这可以通过在第二个 return 语句之前调用 src.Close 来轻松解决，但如果函数更复杂，则问题可能不会那么容易被注意到并解决。 通过引入 defer 语句，我们可以确保文件始终关闭：\nfunc CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() return io.Copy(dst, src) } Defer 语句允许我们考虑在打开它之后立即关闭每个文件，保证无论函数中的返回语句数量如何，文件都将被关闭。\nDefer 语句的行为是直截了当且可预测的。有三个简单的规则：\n1.在评估 defer 语句时，将评估 defer 函数的参数。\n在此示例中，在延迟Println调用时计算表达式“i”。 函数返回后，延迟调用将打印“0”。\nfunc a() { i := 0 defer fmt.Println(i) i++ return } 2.在周围函数返回后，以后进先出顺序执行 defer 函数调用。\n此函数打印“3210”：\nfunc b() { for i := 0; i \u0026lt; 4; i++ { defer fmt.Print(i) } } 3.defer 函数可以读取并分配给返回函数的命名返回值。\n在此示例中，defer 函数在周围函数返回后递增返回值i。因此，此函数返回2：\nfunc c() (i int) { defer func() { i++ }() return 1 } 这样便于修改函数的错误返回值;我们很快就会看到一个例子。\npanic 是一种内置函数，可以阻止普通的控制流并开始触发 Panic 状态。 当函数 F 调用 panic 时，F 的执行停止，F 中的任何 defer 函数都正常执行，然后 F 返回其调用方。 对于调用方，F 表现得像是对 panic 的调用。 进程继续向上移动，直到当前 goroutine 中的所有函数都返回，此时程序崩溃。 可以通过直接调用 panic 来触发 Panic 状态。 它们也可能由运行时错误引起，例如数组越界访问。\nrecover 是一个内置函数，可以重新控制 Panic 状态的 goroutine。 恢复仅在 defer 函数内有用。 在正常执行期间，对 recover 的调用将返回 nil 并且没有其他作用。 如果当前 goroutine 处于 Panic 状态，则对恢复的调用将捕获给予 panic 的值并恢复正常执行。\n这是一个示例程序，演示了 panic 和 defer 的机制：\npackage main import \u0026#34;fmt\u0026#34; func main() { f() fmt.Println(\u0026#34;Returned normally from f.\u0026#34;) } func f() { defer func() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered in f\u0026#34;, r) } }() fmt.Println(\u0026#34;Calling g.\u0026#34;) g(0) fmt.Println(\u0026#34;Returned normally from g.\u0026#34;) } func g(i int) { if i \u0026gt; 3 { fmt.Println(\u0026#34;Panicking!\u0026#34;) panic(fmt.Sprintf(\u0026#34;%v\u0026#34;, i)) } defer fmt.Println(\u0026#34;Defer in g\u0026#34;, i) fmt.Println(\u0026#34;Printing in g\u0026#34;, i) g(i + 1) } 函数 g 接受整型参数 i，如果 i 大于 3 则发生触发 Panic 状态，否则它使用参数 i + 1 调用自身。函数 f 推迟调用 recover 的函数并打印恢复的值（如果它是非nil）。 在阅读之前尝试描绘该程序的输出可能是什么。\n该程序将输出：\nCalling g. Printing in g 0 Printing in g 1 Printing in g 2 Printing in g 3 Panicking! Defer in g 3 Defer in g 2 Defer in g 1 Defer in g 0 Recovered in f 4 Returned normally from f. 如果我们从 f 中删除 defer 函数，则 Panic 状态不会被恢复并到达 goroutine 调用堆栈的顶部，从而终止程序。此修改后的程序将输出：\nCalling g. Printing in g 0 Printing in g 1 Printing in g 2 Printing in g 3 Panicking! Defer in g 3 Defer in g 2 Defer in g 1 Defer in g 0 panic: 4 panic PC=0x2a9cd8 [stack trace omitted] 有关 panic 和 recover 的真实示例，请参阅 Go 标准库中的 json 包。 它使用一组递归函数对 JSON 编码的数据进行解码。 当遇到格式错误的 JSON 时，解析器调用 panic 将堆栈展开到顶级函数调用，该函数调用从 Panic 中恢复并返回适当的错误值（请参阅 decode.go 中 decodeState 类型的 \u0026lsquo;error\u0026rsquo; 和 \u0026lsquo;unmarshal\u0026rsquo; 方法）。\nGo 库中的约定是即使包在内部使用 panic，其外部 API 仍然会显示明确的错误返回值。\ndefer 的其他用法（在关闭文件以外, 前面给出的示例）包括\n释放互斥锁：\nmu.Lock() defer mu.Unlock() 打印页脚；\nprintHeader() defer printFooter() 等更多应用。\n总之，defer 语句（有或没有恐慌和恢复）为控制流提供了一种不寻常且强大的机制。 它可用于模拟由其他编程语言中的专用结构实现的许多功能。 试试看。\n"},{"url":"/post/2019/vim-tutorial/","title":"Vim Tutorial","content":" 从 2015 年使用 Vim 至今已经有 4 个年头了，每次都是碰到一个不会的操作现查，加上不是特别常用，于是促成了“半吊子”的诞生(/ω＼)，近几日偶然间发现 Vim 自带教程，贴出来和大家分享下。\n  进入终端 Terminal 执行命令 vimtutor  洋洋洒洒 30 分钟的简易教程，大家可以手动见证 关于上述内置教程的位置，大家可以通过 vimtutor --help 查看(请注意只有几秒，一闪而逝), 我的位置是 /usr/share/vim/vim74/tutor  root@cloud:/usr/share/vim/vim74/tutor# ls README.el.cp737.txt tutor.de.utf-8 tutor.hr.utf-8 tutor.nb.utf-8 tutor.ru.utf-8 tutor.vim README.el.txt tutor.el tutor.hu tutor.nl tutor.sk tutor.vi.utf-8 README.txt tutor.el.cp737 tutor.hu.cp1250 tutor.nl.utf-8 tutor.sk.cp1250 tutor.zh.big5 tutor tutor.el.utf-8 tutor.hu.utf-8 tutor.no tutor.sk.utf-8 tutor.zh_cn.utf-8 tutor.bar tutor.eo tutor.it tutor.no.utf-8 tutor.sr.cp1250 tutor.zh.euc tutor.bar.utf-8 tutor.eo.utf-8 tutor.it.utf-8 tutor.pl tutor.sr.utf-8 tutor.zh_tw.utf-8 tutor.ca tutor.es tutor.ja.euc tutor.pl.cp1250 tutor.sv tutor.zh.utf-8 tutor.ca.utf-8 tutor.es.utf-8 tutor.ja.sjis tutor.pl.utf-8 tutor.sv.utf-8 tutor.cs tutor.fr tutor.ja.utf-8 tutor.pt tutor.tr.iso9 tutor.cs.cp1250 tutor.fr.utf-8 tutor.ko.euc tutor.pt.utf-8 tutor.tr.utf-8 tutor.cs.utf-8 tutor.hr tutor.ko.utf-8 tutor.ru tutor.uk.utf-8 tutor.de tutor.hr.cp1250 tutor.nb tutor.ru.cp1251 tutor.utf-8 大家可以按照自己喜好的语言选择教程。好了，今天就到这里，我去吃饭了。\n"},{"url":"/post/2019/burning/","title":"Burning","content":"Destiny - NEFFEX\n# 歌词大意 Yeah I don't believe in destiny 我不相信命运 I just do what's best for me 我只做对我有利的事 Don't listen to my enemies 别听信我的敌人的话 They're just full of jealousy 他们满心妒忌 Dah, This legacy 呵 这就是他们的遗产 You gonna see what's left in me 你将看到我的成就 You gonna see success of me 你将看我通向成功 You ain't see the rest of me 你看不到我剩余的部分 I just wanna be the best at what I know 我只想成为自认为最棒的自己 Better then the rest, just watch me grow 比过去的自己更优秀 看我一步步成长吧 Put me to the test and watch me go 你设法考验我 却只能看着我离开 This is my quest, I'm ma make it known 这是我的目标 我会让它人尽皆知 They call me obsessive, oh I know 他们说我痴人说梦 这我知道 Call me selective with my notes 还说我性格挑剔 Call me aggressive with my flow 当我一路顺风的时候 他们说我好强 Call me offensive even though 说我无礼有讨人厌 So I ain't gonna lie life's tough 即使他们这么说我 妒忌我 我也不否认 生活真的很艰辛 Try to get by life's rough 试着解决这些生活中的困难 Try to do it right, it's not enough 试着做好每件事 但这些都不能满足我的野心 Even though you try, you still mess up 即使你努力的尝试 生活还是一团糟 But I'm still gonna fight for what I love 但是为了我所爱的 我甘愿奋斗不息 Still gonna die for what I love 为爱而生 为爱而死 Still gonna try out, won't give up 努力拼搏 永不言弃 Still gonna fight until I've won 除非得到我想要的 They say I'm way too obsessed 他们笑我痴 And I've got nothing left 无所作为 And I'm not quite there yet 无才无能 But those words they'll regret 但迟早他们会为此言感到后悔 Cause I've got something left 因为我正在付出行动 And I'm not giving in 我不会投降 I will not let them win 不会把胜利拱手让人 I won't stop till the end, no 不到最后不罢休 I've been through some injuries 我已承受过痛苦 Mentally and physically 肉体与精神上的痛苦 Studied them religiously 但我真诚的从中吸取教训 So I don't repeat history 为的是不让历史重演 And people won't admit to me 可人们不承认我 They don't want a victory 他们不希望我赢 Bad enough to get it, see 瞧 如此黑心的想要阻止我 They'd rather just go leave it be 可惜他们只会放弃自己的梦想 And no, this journey 可我和他们不一样 I've been on since thirteen 从13岁开始我就踏上了征程 Working hard and learning 刻苦学习 Never stopping searching 不停探索 Dah, it's burning 哈 心中燃起了信念之火 All this passion hurts me 这些激情让我有些喘不过气来 I took action, working 于是我立马采取实际行动 不断努力 Writing down these words, see 瞧 别看我上面写着这些话 No, I'm not okay 其实我过得一点都不好 I just wanna be something 我只想有所作为 I don't wanna be nothing 而不是成为窝囊废 Living all alone 即使一个人独来独往 No, I'm not alright 我却一点都不快乐 I'm just barely getting by 我只是勉强的活着罢了 But I'll tell you I'm just fine 即便如此 我还是会假惺惺的跟你说 我过得可好啦 So you leave me alone 于是你离开了我 They say I'm way too obsessed 他们说我太痴迷了 And I've got nothing left 一无所有 And I'm not quite there yet 无才无能 But those words they'll regret 但迟早他们会为此言感到后悔 Cause I've got something left 因为我已经开始有收获了 And I'm not giving in 并且我绝不会投降 I will not let them win 不会把胜利拱手让人 I won't stop till the end, no 生命不止 奋斗不息 "},{"url":"/post/2019/mysql-m2b-in-action/","title":"Mysql M2B in Action with Docker","content":" M2B: 主主备份(DIY, 哈哈)。最近和数据库备份杠上了，碍于手上没有足够的服务器，于是在一个服务器上使用 Docker 运行两个 Mysql 实例, 下面是主主备份的具体流程, 每一步都不能跳过，请仔细阅读。\n 1. 运行两个 mysql 实例: mysql-1 和 mysql-2  确保两台服务器上有相同的数据。\n root@cloud:~# docker run -p 10028:3306 --name mysql-1 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 root@cloud:~# docker run -p 10029:3306 --name mysql-2 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 2. 两个实例分别修改配置文件和创建复制账号  启用二进制日志，选择唯一的服务器ID，并创建复制账号\n # mysql-1 # 进入实例 mysql-1 root@cloud:~# docker exec -it mysql-1 bash # 修改配置文件 my.cnf root@343cef5a6f96:/# vim /etc/mysql/my.cnf [mysqld] server-id = 128 log_bin = mysql-bin relay-log = mysql-relay-bin # replicate-wild-do-table=scheme.% # replicate-wild-ignore-table=schema.% log-slave-updates = on slave-skip-errors = all auto-increment-offset = 1 auto-increment-increment = 2 binlog_format = mixed expire_logs_days = 10 max_binlog_size = 100 !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mysql.conf.d/ # mysql-2 # 进入实例 mysql-2 root@cloud:~# docker exec -it mysql-2 bash # 修改配置文件 my.cnf root@343cef5a6f96:/# vim /etc/mysql/my.cnf [mysqld] server-id = 129 log_bin = mysql-bin relay-log = mysql-relay-bin # replicate-wild-do-table=scheme.% # replicate-wild-ignore-table=schema.% log-slave-updates = on slave-skip-errors = all auto-increment-offset = 2 auto-increment-increment = 2 binlog_format = mixed expire_logs_days = 10 max_binlog_size = !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mysql.conf.d/ # 退出容器, 重启两个 mysql 实例 root@cloud:~# docker retart mysql-1 mysql-2    参数 描述     server-id 必须唯一, 建议使用服务器IP   log_bin 开启二进制日志功能，mysql-bin是命名格式，会生成文件名为mysql-bin.000001、mysql-bin.000002等日志文件   relay-log 作为从服务器时的中继日志   replicate-wild-do-table=scheme.% 限制slave只同步那些匹配指定模式的数据表   replicate-wild-ignore-table=scheme.% 是复制过滤选项，可以过滤不需要复制同步的数据库或表，如“scheme.%”指不复制MySQL库下的所有表，依此类推，多个数据库就多写几行   log-slave-updates slave 将复制事件写进自己的二进制日志   slave-skip-errors 跳过主从复制中遇到的所有错误或指定类型的错误,避免 slave 端复制中断   auto-increment-offset=1 主键自增规则，自增偏移（从1开始），单数   auto-increment-increment=2 主键自增规则，自增因子（每次加2）   binlog_format 主从复制的格式(mixed,statement,row,默认格式是 statement)   expire_logs_days = 10 expire_logs_days = 10日志保存天数：10天    创建复制账号并授权\n# mysql-1 创建复制账号 root@cloud:~# mysql -uroot -h127.0.0.1 -p123456 -P10028 mysql\u0026gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO repl@'%' IDENTIFIED BY '123456'; Query OK, 0 rows affected, 1 warning (0.01 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.00 sec) # mysql-2 创建复制账号 root@cloud:~# mysql -uroot -h127.0.0.1 -p123456 -P10029 mysql\u0026gt; GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO repl@'%' IDENTIFIED BY '123456'; Query OK, 0 rows affected, 1 warning (0.01 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.00 sec) 3.将每个主库设置为对方的备库，使用新创建的二进制日志开始工作  将每个主库设置为对方的备库，使用新创建的二进制日志开始工作\n # mysql-2 增加 mysql-1 root@cloud:~# mysql -uroot -h127.0.0.1 -p123456 -P10028 mysql\u0026gt; show master status; +------------------+----------+ | File | Position | +------------------+----------+ | mysql-bin.000001 | 1080 | 1 row in set (0.00 sec) root@cloud:~# mysql -uroot -h127.0.0.1 -p123456 -P10029 mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='Your_Server_IP',MASTER_USER='repl', MASTER_PASSWORD='123456', MASTER_PORT=10028, MASTER_LOG_FILE='mysql-bin.00001', MASTER_LOG_POS=1080; Query OK, 0 rows affected, 1 warning (0.03 sec) mysql\u0026gt; show master status; +------------------+----------+ | File | Position | +------------------+----------+ | mysql-bin.000001 | 154 | 1 row in set (0.00 sec) root@cloud:~# mysql -uroot -h127.0.0.1 -p123456 -P10028 mysql\u0026gt; CHANGE MASTER TO MASTER_HOST='Your_Server_IP',MASTER_USER='repl', MASTER_PASSWORD='123456', MASTER_PORT=10029, MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=154; Query OK, 0 rows affected, 1 warning (0.03 sec) mysql\u0026gt; start slave; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; show slave status\\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: Your_Server_IP Master_User: repl Master_Port: 10028 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 2451 Relay_Log_File: mysql-relay-bin.000002 Relay_Log_Pos: 1234 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes # 看到 Slave_IO_Running 和 Slave_SQL_Running 均为 Yes 表明配置成功 4. 最后验证主主备份是否成功 # mysql-1 上创建 schema test table sync root@cloud:~# mysql -h127.0.0.1 -p123456 -P10028 mysql\u0026gt; CREATE DATABASE test; mysql\u0026gt; USE test; mysql\u0026gt; CREATE TABLE `test`.`sync` ( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(45) NULL COMMENT '名称', `remarks` VARCHAR(45) NULL COMMENT '备注', PRIMARY KEY (`id`)) ENGINE = InnoDB DEFAULT CHARACTER SET = utf8; Query OK, 0 rows affected (0.01 sec) # 插入一条数据 mysql\u0026gt; insert into sync (`name`, `remarks`) values ('cloud', '平台'); Query OK, 1 row affected (0.00 sec) # mysql-2 上查询记录和再新增两天记录，验证 id 是否按规则生成 root@cloud:~# mysql -h127.0.0.1 -p123456 -P10029 mysql\u0026gt; USE test; mysql\u0026gt; select * from sync; +----+-------+---------+ | id | name | remarks | +----+-------+---------+ | 1 | cloud | 平台 | +----+-------+---------+ 1 row in set (0.00 sec) mysql\u0026gt; insert into sync (`name`, `remarks`) values ('a', 'A'); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into sync (`name`, `remarks`) values ('b', 'B'); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; select * from sync; +----+-------+---------+ | id | name | remarks | +----+-------+---------+ | 1 | cloud | 平台 | | 2 | a | A | | 4 | b | B | +----+-------+---------+ 3 rows in set (0.01 sec) mysql\u0026gt; 此处应该有掌声！！！ 注: mysql 的镜像中没有 vim , 遇到 vim 不存在时， 需要安装一下\napt-get update \u0026amp;\u0026amp; apt-get install vim -y "},{"url":"/post/2019/docker-run-mysql-error/","title":"Cannot open shared object file: Permission denied","content":" 我想通过 docker 来运行 mysql 实例, 网上教程一大堆，结果以为很简单的事，搞了大半天, 记录下来，希望能帮到大家。\n 环境  Ubuntu 14.04 Docker 18.09 Mysql 5.7  问题 root@cloud:~# docker run --name mysql -d -e MYSQL_ROOT_PASSWORD=12345 mysql:5.7 11637add4a41b827a9691fe6e77fba13ae63319d74713c64ef2e92276df6583f root@cloud:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@cloud:~# docker logs mysql ERROR: mysqld failed while attempting to check config command was: \u0026quot;mysqld --verbose --help --log-bin-index=/tmp/tmp.m22w4ZgLhP\u0026quot; mysqld: error while loading shared libraries: libpthread.so.0: cannot open shared object file: Permission denied 解决方案 解决过程中, 尝试各种以 权限 为中心的解决办法，均无效，有的网站上把 /usr/bin 的权限放开后就可以了，但是本人尝试无效。大家也可以试试。\n终极方案: 升级 Ubuntu 系统到 16.04, 具体升级方法，大家可以参考这篇文章, 写的很细。\n"},{"url":"/post/2019/cmd-activate-win10/","title":"通过命令行激活Win10","content":" 一直以来，网上各种激活工具，层出不穷，但是更多的是病毒和垃圾广告， 费心寻找之下，终于找到这种简单、免安装的方式来激活。 缺点是只有 180 天有效期。\n 方法 1. 通过 slmgr slmgr(Software LiscenceManager)\n// 1.检查是VL版本 slmgr /dlv // 产品密钥通道: 包含VL的字符串 如果不包含则终止此方法 // 2.激活系统 slmgr /skms kms.03k.org slmgr /ato 2. 一键激活 参考这篇文章: http://kms.cangshui.net/\n参考文章  https://www.jianshu.com/p/5886e8cbbaf3 https://03k.org/kms.html  "},{"url":"/post/2019/plugin-statistic/","title":"Plugin Statistic","content":" 统计项目中的有效代码行数和注释是一件很有趣的事, 安利大家一款统计代码行数的插件 statistic\n 安装  进入 File -\u0026gt; Settings -\u0026gt; Plugins 搜索关键字 statistic -\u0026gt; Search in repositories 选中插件 -\u0026gt; Install 安装成功后重启 Pycharm  使用  以 Flask 为例\n   底边栏 statistic   Refresh   Detail      表头 描述     Source File 单个文件名   Total Lines 单个文件总行数   Source code Lines 纯代码行数   Source code Lines[%] 纯代码行数百分比   Comment Lines 注释行数   Comment Lines[%] 注释行数百分比   Blank Lines 空行行数   Blank Lines[%] 空行行数百分比    "},{"url":"/post/2018/golang-pointers/","title":"Golang何时该使用指针?","content":"Github 原文\n 一个函数何时该用指针类型做receiver对初学者而言一直是个头疼的问题。如果不知道该如何取舍，选择指针类型的receiver。但有些时候value receiver更加合适，比如对象是一些轻量级的不变的structs，使用value receiver会更加高效。下面是列举了一些常用的判断指导。\n  如果receiver是map、func或者chan，不要使用指针 如果receiver是slice并且该函数并不会修改此slice，不要使用指针 如果该函数会修改receiver，此时一定要用指针 如果receiver是struct并且包含互斥类型sync.Mutex，或者是类似的同步变量，receiver必须是指针，这样可以避免对象拷贝 如果receiver是较大的struct或者array，使用指针则更加高效。多大才算大？假设struct内所有成员都要作为函数变量传进去，如果觉得这时数据太多，就是struct太大 如果receiver是struct，array或者slice，并且其中某个element指向了某个可变量，则这个时候receiver选指针会使代码的意图更加明显 如果receiver使较小的struct或者array，并且其变量都是些不变量、常量，例如time.Time，value receiver更加适合，因为value receiver可以减少需要回收的垃圾量 最后，如果不确定用哪个，使用指针类的receiver  "},{"url":"/post/2018/markdown-merge-cells/","title":"Markdown中实现合并单元格","content":"Method  使用 \u0026lt;br\u0026gt; 换行符(隐性换行) 使用 html 标签 rowspan 和 colspan excel 转 html  Raw \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026quot;2\u0026quot;\u0026gt;值班人员\u0026lt;/th\u0026gt; \u0026lt;th colspan=\u0026quot;2\u0026quot;\u0026gt;星期一\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Preview "},{"url":"/post/2018/wkhtmltopdf-zh-display-error/","title":"wkhtmltopdf 中文显示有误, 显示“口”方框的解决方案","content":"运行环境  Ubuntu 14.04.2 LTS wkhtmltopdf 0.9.9 test.html 测试文件的编码为 UTF-8，文件内部标记编码也是UTF-8，如下所示：  \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=utf-8\u0026quot;\u0026gt; 执行过程 $ wkhtmltopdf test.html test.pdf Loading page (1/2) Printing pages (2/2) Done 检查转化后的 pdf 文件，中文显示有问题\n解决方案  在 Windows 目录( C:\\WINDOWS\\Fonts\\ )中找到文件 simsun.ttc 大概 17M 左右 拷贝至 /usr/share/fonts/chinese/TrueType/simsun.ttc，如果目录 chinese/TrueType 不存在，则手动创建 加载缓存 fc-cache -fv 再次执行 wkhtmltopdf test.html test.pdf 检查显示，完美。   有些博客中会建议拷贝 *.ttf 之类的文件，目前我没有亲测通过，暂不加入此。\n "},{"url":"/post/2018/05/aliyun-ecs-connect-error/","title":"阿里云ECS无法访问","content":" 今天有一朋友让我帮忙看下他的云服务器，他说服务器无法远程访问，即使重启了也不行。说来挺惭愧，我也搞了半天没查出来问题在哪！于是我帮他申请工单，没想到阿里云工程师反馈很快，给了他最大权限，三下五除二，问题被解决了。\n 工程师 XXXXX 号: 因为您服务器的网络是专有网络，专有网络服务器的 公网ip 是通过 nat 映射到 内网网卡的，所以您服务器内是无法直接监听 公网ip 的。还请您知晓，谢谢 服务器sshd服务无法启动，报错: error: Bind to port 22 on 101.132.36.203 failed: Cannot assign requested address. fatal: Cannot bind any address. 其实他说的这个原因，我也查到了，但是我误解了assign的意思。assign 此处的含义是“指定”, 而不是“分配”。\n解决方案: 编辑 /etc/ssh/sshd_config 注释 #ListenAddress 101.132.36.203\n"},{"url":"/post/2018/05/clean-up-disk-space-on-win10/","title":"Clean Up Disk Space on Win10","content":" 今天win10一不小心被升级了，多出一个文件夹Windows.old 将近20G把磁盘空间快占满了，寻了下资料，怎么合理删除这个文件夹？\n 步骤  Win+S 输入disk 选择存储设置 选择立即释放空间 选中需要好删除的文件  需要清理系统磁盘的童鞋可以试试。\n"},{"url":"/post/2018/05/pip-install-pipenv-fail/","title":"Pip Install Pipenv Fail","content":" 提示: \u0026lsquo;install_requires\u0026rsquo; must be a string or list of strings containing valid project/version requirement specifiers\n 解决方式(pipenv版本管理)\n思路: 先装次新版本，再装最新版本\npip install pipenv==11.10.4 pip install pipenv "},{"url":"/post/2018/05/invisible-postman/","title":"Invisible Postman","content":" 软件Postman跑到屏幕外拉不回来怎么办？\n 环境  Thinkpad T460P Win10 外接一个显示屏  解决方案  按 Alt + Tab 键，确保该窗口处于激活位置 再按 Alt + Space 键，激活控制菜单 按 M 键，上下左右操作，将窗口移到中央位置  "},{"url":"/post/2018/05/vscode-cmder-win10/","title":"VSCode配置Cmder作为默认的终端(Shell)","content":" Windows系统中的默认终端不好用，于是使用了Cmder。与此同时, VSCode中的默认终端也不招人喜欢，我要Cmder移植到VSCode中怎么做呢？\n 环境  Cmder 安装目录 C:\\Software\\cmder Win10  配置 第一步: 准备启动脚本 cmder安装目录下新建文件vscmd.bat\n使用VSCode打开vscmd.bat，写入下面代码\n@echo off \u0026quot;C:\\Software\\cmder\\vendor\\init.bat\u0026quot; 第二步: VSCode中配置启动项和参数 VSCode找到用户设置(使用快捷键Ctrl+,) 打开settings.json 添加下面配置\n{ \u0026quot;terminal.integrated.shell.windows\u0026quot;: \u0026quot;cmd.exe\u0026quot;, \u0026quot;terminal.integrated.shellArgs.windows\u0026quot;: [ \u0026quot;/K\u0026quot;, \u0026quot;C:/Software/cmder/vscmd.bat\u0026quot; ], } 第三步: 重新启动，检验成果 关闭VSCode，再重新打开，使用 Ctrl + 反引号(`) ，见证奇迹的时刻。\n"},{"url":"/post/2017/docker-for-win10/","title":"How To Install Docker On Win10","content":" PC: Thinkpad T460p\n docker-client docker-toolbox\n"},{"url":"/post/2017/high-speed-seat/","title":"高铁座位为什么没有E?","content":" 以前一直没有注意过这个问题,直至今天乘坐G1932次列车从上海虹桥开往西安北站.我所选的是1号车厢8F座位,我看了下周围的座次,只有AC, DF后缀结尾的座次;于是上百度上搜索了一下,找到了答案\u0026hellip;\n 高铁的座次设计是沿袭了航空的座次设计, 航空普遍是ABCDEF, A和F靠窗座位, C和D为过道座位, 于是高铁上的一等座2+2就是AC+DF, A和F同样是靠窗, C和D为过道座位, 同下面这张图, 咱可以看的更加详细\n"},{"url":"/post/2017/mysql-limit/","title":"MySQL的limit用法和分页查询的性能优化","content":" 学习任何东西都可以按照3W的框架进行，容器技术也是一样，先回答 What、Why 和 How 这三个问题。\n CloudMan-每天5分钟玩转容器技术（6）\n 我非常赞同CloudMan的观点, 下面咱就以这三个问题来讨论今天的主题\n What-Mysql中的LIMIT是干啥的? 在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。\nSELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。如果给定一个参数(rows), 偏移量offset默认为0, 指定返回[:rows]的数据; 如果给定两个参数(offset, rows)，offset指定第一个返回记录行的偏移量，rows指定返回记录行的最大数目。\nmysql\u0026gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 获得开头的几行数据\nmysql\u0026gt; SELECT * FROM table LIMIT 10; // 检索记录行 0-9 获得结尾的几行数据\nmysql\u0026gt; SELECT * FROM table LIMIT 100,-1; // 检索记录行 100-last. Why-为什么需要为分页查询做优化?  随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似下面示例。总而言之，越往后分页，LIMIT语句的偏移量(offset)就会越大，速度也会明显变 随着业务的复杂度越来越高, 查询条件不断增多, 可想而知, 速度也会越来越慢  SELECT * FROM users WHERE age = 12 ORDER BY id LIMIT 10000, 20 How-分页查询如何优化?   提速原理: 避免全表扫描,而是通过索引找到指定位置,于是就相当于只是扫描了指定数量(rows)的数据\n  实现方式:\n 子查询分页方式  SELECT * FROM users WHERE id \u0026gt;= (SELECT id FROM users WHERE age = 12 ORDER BY id LIMIT 10000, 1) LIMIT 20  JOIN分页方式  暂缺示例   "},{"url":"/post/2017/python-config/","title":"configparser(PY3) VS ConfigParser(PY2)","content":" 关于使用ConfigParser,我的小伙伴想实现特殊的需求: 1.配置中的参数均大写; 2.配置文件中\u0026quot;=\u0026ldquo;等号两侧无空格, 于是摸索中写下这篇文章, 方便有缘人\n 范例: 配置文件config.ini长成这样\n[test] TEST=A AUTO=B HAHA=C 小伙伴使用的是python2的环境,所有优先考虑ConfigParser(ConfigParser库是自带的嘛)\n# https://github.com/hugoxia/Python/config-demo/config.py # -*- coding: utf-8 -*- from ConfigParser import ConfigParser class CustomConfig(ConfigParser): def __init__(self, defaults=None): ConfigParser.__init__(self, defaults=defaults) def write(self, fp): \u0026#34;\u0026#34;\u0026#34;Write an .ini-format representation of the configuration state.\u0026#34;\u0026#34;\u0026#34; if self._defaults: fp.write(\u0026#34;[%s]\\n\u0026#34; % \u0026#34;DEFAULT\u0026#34;) for (key, value) in self._defaults.items(): fp.write(\u0026#34;%s= %s\\n\u0026#34; % (key, str(value).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\n\\t\u0026#39;))) fp.write(\u0026#34;\\n\u0026#34;) for section in self._sections: fp.write(\u0026#34;[%s]\\n\u0026#34; % section) for (key, value) in self._sections[section].items(): if key == \u0026#34;__name__\u0026#34;: continue if (value is not None) or (self._optcre == self.OPTCRE): key = \u0026#34;=\u0026#34;.join((key, str(value).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\n\\t\u0026#39;))) fp.write(\u0026#34;%s\\n\u0026#34; % (key)) fp.write(\u0026#34;\\n\u0026#34;) class Config(object): def __init__(self, path): self.config_path = path self.conf = CustomConfig() self.conf.optionxform = str self.conf.read(self.config_path) def get(self, field, key): return self.conf.get(field, key) def set(self, field, key, value): return self.conf.set(field, key, value) def save(self): with open(self.config_path, \u0026#39;w\u0026#39;) as f: self.conf.write(f) if __name__ == \u0026#34;__main__\u0026#34;: config = Config(\u0026#34;./config.ini\u0026#34;) config.set(\u0026#34;test\u0026#34;, \u0026#34;HAHA\u0026#34;, \u0026#34;D\u0026#34;) config.save() 有没有觉得很麻烦,咱来看看configparser的表现\n# https://github.com/hugoxia/Python/config-demo/config_py3.py # -*- coding: utf-8 -*- import configparser class Config(object): def __init__(self, path): self.config_path = path self.conf = configparser.ConfigParser() self.conf.optionxform = str self.conf.read(self.config_path) def get(self, field, key): return self.conf.get(field, key) def set(self, field, key, value): return self.conf.set(field, key, value) def save(self): with open(self.config_path, \u0026#39;w\u0026#39;) as f: self.conf.write(f, space_around_delimiters=False) if __name__ == \u0026#34;__main__\u0026#34;: config = Config(\u0026#34;./config.ini\u0026#34;) config.set(\u0026#34;test\u0026#34;, \u0026#34;HAHA\u0026#34;, \u0026#34;D\u0026#34;) config.save() 总结:\n 针对保留原大小写的问题, ConfigParser和configparser的处理方式一样  self.optionxform = str # 中文的话,会出现乱码  针对空格的问题, ConfigParser需要复写write方法,而configparser的write方法自带一个参数space_around_delimiters, 通过修改这个参数可以直接实现.有兴趣的可以看下这两个库的原码. "},{"url":"/post/2017/wsgi-uwsgi/","title":"WSGI，uwsgi和uWSGI的区别","content":"WSGI Web服务器网关接口\n WSGI(Python Web Server Gateway Interface, Web服务器网关接口)是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口\n uwsgi uwsgi协议\n uwsgi同WSGI一样是一种通信协议。uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。\n uWSGI uWSGI\n uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。\n  最流行的 uWSGI 服务器是 uwsgi  "},{"url":"/post/2017/github-pages-https/","title":"HTTPS for GitHub Pages","content":" 福利来啦, Github响应小伙伴们的号召, 于2016年6月15日, 推出https服务, 为username.github.io站点添加Enforce HTTPS选项, 详情请参阅https://github.com/blog/2186-https-for-github-pages\n 具体操作参见Securing your GitHub Pages site with HTTPS 注意点:  使用自定义域的GitHub页面不支持HTTPS(即是说,Custom domain选项置空并保存) 使用HTTPS之后, 必须删除文件CNAME 最后一点也是最重要的一点, 设置成功之后,需要等待十几分钟才能生效,耐心等待 "},{"url":"/post/2017/python-exit/","title":"Python 中的 exit()、sys.exit() 和 os._exit()的区别","content":"Python官方解释 exit()  exit\n Objects that when printed, print a message like “Use quit() or Ctrl-D (i.e. EOF) to exit”, and when called, raise SystemExit with the specified exit code.\n简言之: 抛出 SystemExit 异常. 用于给交互式Shell退出.\nsys.exit()  sys.exit\n Exit from Python. This is implemented by raising the SystemExit exception, so cleanup actions specified by finally clauses of try statements are honored, and it is possible to intercept the exit attempt at an outer level.\n简言之: 抛出 SystemExit 异常, 可以用try捕获异常执行清理工作. 用于程序内部.\nos._exit()  os._exit(n)\n Exit the process with status n, without calling cleanup handlers, flushing stdio buffers, etc. Note: The standard way to exit is sys.exit(n). _exit() should normally only be used in the child process after a fork().\n简言之: 直接退出, 不抛出异常. 用于子进程的退出.\n参考文档  python 中 os._exit()， sys.exit()， exit() 的区别是什么(知乎) The difference between exit() and sys.exit() in Python?(stackoverflow) Python 中的 exit() 和 sys.exit()(jaminzhang\u0026rsquo;s blog)  "},{"url":"/post/2017/docker-note/","title":"Docker学习笔记","content":"Docker简介  What is Docker Docker is the world’s leading software container platform. Developers use Docker to eliminate “works on my machine” problems when collaborating on code with co-workers. Operators use Docker to run and manage apps side-by-side in isolated containers to get better compute density. Enterprises use Docker to build agile software delivery pipelines to ship new features faster, more securely and with confidence for both Linux and Windows Server apps.\n  Docker是世界领先的软件容器平台。开发人员使用Docker来消除与同事的代码协作时的“我机器上的工作”问题。运营商使用Docker在独立的容器中并行运行和管理应用程序，以获得更好的计算密度。企业使用Docker构建灵活的软件传送管道，可以更快，更安全地运行新功能，并且对于Linux和Windows Server应用程序都有信心。\n 什么是容器?  What is Container Using containers, everything required to make a piece of software run is packaged into isolated containers. Unlike VMs, containers do not bundle a full operating system - only libraries and settings required to make the software work are needed. This makes for efficient, lightweight, self-contained systems and guarantees that software will always run the same, regardless of where it’s deployed.\n  使用容器，使一件软件运行所需的一切都被打包成隔离的容器。与虚拟机不同，容器不捆绑完整的操作系统 - 只需要使软件工作所需的库和设置。这使得高效，轻便，自包含的系统，并保证软件将始终运行相同，无论它在哪里部署。\n  Linux容器技术 vs 虚拟机   "},{"url":"/post/2017/go-note/","title":"Go学习笔记","content":"Go笔记 {% blockquote Go https://golang.org Welcome to golang.org %} The Go programming language is an open source project to make programmers more productive. {% endblockquote %}\n Go编程语言是一个开源项目，使程序员更有成效\n Go简介 {% blockquote Go Docs https://golang.org/doc/ %} Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It\u0026rsquo;s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language. {% endblockquote %}\n Go语言的优点  脚本化的语法, 非常容易编写程序, 新手容易上手 静态类型+编译型, 程序运行速度有保障 原生的支持并发编程, 降低开发、维护成本、程序更好的执行   Go语言的缺点  语法糖没有Python和Ruby那么多 目前的程序运行速度还不及C 第三方函数库暂时不像绝对主流的编程语言那样多(随着Go的流行，这不是问题)    Go的安装和配置 可以到官网下载相应系统的go版本,下面说说Linux下的安装方式\n Linux(源码安装)  $ sudo curl -O https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz $ sudo tar -zxf go1.8.1.linux-amd64.tar.gz -C /usr/local $ cd /usr/local/go \u0026amp;\u0026amp; bin/go version # 验证安装结果 go version go1.8.1 linux/amd64   Linux配置\n在~/.profile中最后添加下面语句，添加完之后执行source ~/.profile\n  export PATH=$PATH:/usr/local/go/bin "},{"url":"/post/2017/python-json/","title":"关于Python中json库的一些整理","content":"json.dump和json.dumps的区别(来自Stackoverflow的释疑)  json.dump   Serialize obj as a JSON formatted stream to fp (a .write()-supporting file-like object). If ensure_ascii is False, some chunks written to fp may be unicode instances.\n  json.dumps   Serialize obj to a JSON formatted str. If ensure_ascii is False, all non-ASCII characters are not escaped, and the return value may be a unicode instance.\n ensure_ascii的神奇之处 Python Docs\n If ensure_ascii is true (the default), all non-ASCII characters in the output are escaped with \\uXXXX sequences, and the result is a str instance consisting of ASCII characters only. If ensure_ascii is False, some chunks written to fp may be unicode instances. This usually happens because the input contains unicode strings or the encoding parameter is used. Unless fp.write() explicitly understands unicode ( as in codecs.getwriter ) this is likely to cause an error.\n 实战 \u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; data = [u\u0026#34;她\u0026#34;, u\u0026#34;是\u0026#34;, u\u0026#34;美女\u0026#34;] \u0026gt;\u0026gt;\u0026gt; output1 = json.dumps(data) \u0026gt;\u0026gt;\u0026gt; output1 \u0026#39;[\u0026#34;\\\\u5979\u0026#34;, \u0026#34;\\\\u662f\u0026#34;, \u0026#34;\\\\u7f8e\\\\u5973\u0026#34;]\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(output1) [\u0026#34;\\\\u5979\u0026#34;, \u0026#34;\\\\u662f\u0026#34;, \u0026#34;\\\\u7f8e\\\\u5973\u0026#34;] \u0026gt;\u0026gt;\u0026gt; output2 = json.dumps(data, ensure_ascii=False) \u0026gt;\u0026gt;\u0026gt; outout2 u\u0026#39;[\u0026#34;\\u5979\u0026#34;, \u0026#34;\\u662f\u0026#34;, \u0026#34;\\u7f8e\\u5973\u0026#34;]\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(output2) [\u0026#34;她\u0026#34;, \u0026#34;是\u0026#34;, \u0026#34;美女\u0026#34;] 参数cls的妙用之处理时间 import json from datetime import datetime class DateTimeEncoder(json.JSONEncoder): \u0026#34;\u0026#34;\u0026#34;convert datetime to string in json.dumps\u0026#34;\u0026#34;\u0026#34; def default(self, obj): if isinstance(obj, datetime): encoded_object = obj.strftime(\u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;) elif isinstance(obj, date): encoded_object = obj.strftime(\u0026#39;%Y-%m-%d\u0026#39;) else: encoded_object = json.JSONEncoder.default(self, obj) return encoded_object if __name__ == \u0026#34;__main__\u0026#34;: data = {\u0026#34;now\u0026#34;: datetime.now()} print(json.dumps(data, cls=DateTimeEncoder)) # output: {\u0026#34;now\u0026#34;: \u0026#34;2017-04-19 16:32:53\u0026#34;} "},{"url":"/post/2017/pycharm-jump/","title":"Pycharm实现前进/后退","content":" 操作系统: Ubuntu14.04; Pycharm版本: 2016.3; 这里的前进指的是追踪函数源码, 后退是前进的反方向。\n 前进  Ctrl+B Ctrl+Q+\u0026lt;F4\u0026gt;  后退  View -\u0026gt; ToolBar -\u0026gt; √ ToolBar(出现工具栏，工具栏中有前进和后退) Ctrl+ Alt + Left(我试了没生效，不知道为啥) 罗技G502鼠标左侧前进键和后退键完美兼容Pycharm(意外之喜) "},{"url":"/post/2017/heartbeat/","title":"玩的就是“心跳”","content":"心跳检测是什么？ 这里的“心跳”，可不是男女之间心动啥的“砰砰砰”。\n 心跳检测是判断对方(设备，进程或其它网元)是否正常进行，一般采用定时发送简单的通讯包，如果长时间未收到对方响应，则判断对方已经挂掉。 心跳机制是服务端和客户端检测对方是否在线的一种方式。 心跳包就是客户端定时发送简单的信息给服务端告诉它我还在，服务端视情况而定给客户单返回合适信息，一般情况下是客户端给服务端发心跳包。  为什么要用心跳机制？  服务端不能有效判断客户端是否在线。 心跳包可以用于长连接的保活和断线处理。  怎么代码实现心跳机制？  客户端每隔一个时间间隔发生一个探测包给服务器。 客户端发包时启动一个超时定时器。 服务器端接收到检测包，应该回应一个包。 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器。 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了。  Python代码实现心跳检测  具体代码参见Github\n  server  #!/usr/bin/python #encoding:utf-8 import socket, sys, json from thread import * BUF_SIZE = 4096 HOST = socket.gethostname() PORT = 7878 try: server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) except socket.error, e: print \u0026#34;Error creating socket: %s\u0026#34; % e sys.exit() try: server.bind((HOST, PORT)) except socket.error: print \u0026#34;Bind failed!\u0026#34; sys.exit() print \u0026#34;Socket bind complete\u0026#34; server.listen(10) print \u0026#34;Socket now listening\u0026#34; def clientthread(coon): coon.send(\u0026#34;Welcome to the server!\u0026#34;) while True: try: data = coon.recv(BUF_SIZE) data_loaded = json.loads(data) print \u0026#34;ip: {}|status: {}|pid: {}\u0026#34;.format( str(data_loaded[\u0026#39;ip\u0026#39;]), data_loaded[\u0026#39;status\u0026#39;], str(data_loaded[\u0026#39;pid\u0026#39;] ) except socket.error: print \u0026#34;One Client (IP: %s) Connected over!\u0026#34; % data_loaded[\u0026#39;ip\u0026#39;] break coon.close() while True: coon, addr = server.accept() print \u0026#34;Connected with %s: %s\u0026#34; % (addr[0], str(addr[1])) start_new_thread(clientthread, (coon,)) server.close()  client  #!/usr/bin/python #encoding:utf-8 import socket, sys, os import time, json host = socket.gethostname() # 这里获得的是本地，视情况而定 port = 7878 BUF_SIZE = 4096 try: client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) except socket.error, e: print \u0026#34;Error creating socket: %s\u0026#34; % e sys.exit() try: remote_ip = socket.gethostbyname(host) except socket.gaierror: print \u0026#34;Hostname couldn\u0026#39;t be resolved. Exciting\u0026#34; sys.exit() try: client.connect((remote_ip, port)) client.setblocking(0) # set the socket is not blocking print \u0026#34;Socket connected to %son ip %s\u0026#34; % (host, remote_ip) except socket.gaierror, e: #address related error print \u0026#34;connected to server error%s\u0026#34; % e sys.exit() #send heart_beat while True: host_name = socket.gethostname() data_to_server = { \u0026#39;ip\u0026#39;: socket.gethostbyname(host_name), \u0026#39;status\u0026#39;: \u0026#39;alive\u0026#39;, \u0026#39;pid\u0026#39;: os.getpid() } data_dumped = json.dumps(data_to_server) try: client.sendall(data_dumped) except socket.error: print \u0026#34;Send failed!!\u0026#34; sys.exit() print \u0026#39;I - \u0026#39;, os.getpid(), \u0026#39;- am alive.\u0026#39; time.sleep(50) client.close() "},{"url":"/post/2017/pnvssn/","title":"由罗技G502鼠标引起的“聒噪”","content":" 昨晚在京东商城上买了一个罗技鼠标，今天上午到货，于是寻思着吧，找下序列号，查下它是不是正品。按照网友的提示，我在包装盒上翻来覆去，就是找不到可以刮的地方，看到P/N,S/N,这都是啥？？？\n  P/N: Part Number(部件编号) S/N: Serial Number(产品序列号) L/N: Lot Number(批号)  有时候咱买回来的产品可能有好几个S/N, 像我的鼠标就是包装盒子上有一个，鼠标绳上也有一个，并且两个都不一样，盒子上标的是1647XXXXXXXXX,鼠标上标的是1648XXXXXXXX，其实不用担心，这并不能说明鼠标不是正品，只是盒子生产的比鼠标早而已，1647表示16年第47周生产的产品。先到这，后续补充再添加。\n"},{"url":"/post/2017/pycharm-autopep8/","title":"Pycharm配置autopep8到菜单","content":"{% note success %} Pycharm可以自动检测PEP8规范, 菜单Code–\u0026gt;Reformat Code可以自动调整代码,但是效果一般,只能实现简单的规范代码; 为了满足需要, 可以安装autopep8来自动修改文件实现PEP8规范. {% endnote %}\n安装autopep8 pip install autopep8 Pycharm中进行设置  Settings–\u0026gt;Tools–\u0026gt;External Tools, 点击+按钮  Name: autopep8 (可以自定义) Tools settings:  Programs: autopep8(Ubuntu和Windows) Parameters: --in-place --aggressive --aggressive $FilePath$ Working directory: $ProjectFileDir$     点击Output Filters...  点击+，名称可以任意填写 Regular expression to match output: $FILE_PATH$\\:$LINE$\\:$COLUMN$\\:.*    使用  方法一: 代码上右击–\u0026gt;External Tool–\u0026gt;autopep8 方法二: Tools-\u0026gt;External-\u0026gt;autopep8  注  Ubuntu: 示例绝对路径(/home/hugo/.virtualenvs/test/bin/autopep8) Windows: 示例绝对路径(C:\\Users\\hugo\\AppData\\Local\\Programs\\Python\\Python35\\Scripts\\autopep8.exe) "},{"url":"/post/2017/python-format/","title":"Python中字符串格式化符号和转义字符含义","content":" 这篇文档整理自鱼C论坛, 感谢作者输出,我只是一枚搬运工\u0026hellip;\n 字符串格式化符号含义    符号 说明     %c 格式化字符及其ASCII码   %s 格式化字符串   %d 格式化整数   %o 格式化无符号八进制数   %x 格式化字符号十六进制数   %X 格式化字符号十六进制数(大写)   %f 格式化定点数,可指定小数点后的精度   %e 用科学计数法格式化定点数   %E 作用同%e, 用科学计数法格式化定点数   %g 根据值的大小决定使用%f或%e   %G 作用同%g, 根据值的大小决定使用%f或者%E    格式化操作符辅助指令    符号 说明     m.n m是显示的最小总宽度,n是小数点后的位数   - 用于左对齐   + 在正数前面显示加好(+)   # 在八进制数前面显示'0o', 在十六进制数前面显示'0x\u0026rsquo;或'0X'   0 显示的数字前面填充'0\u0026rsquo;取代空格    字符串转义字符含义    符号 说明     ' 单引号   \u0026quot; 双引号   \\a 发出系统响铃声   \\b 退格符   \\n 换行符   \\t 横向制表符(TAB)   \\v 纵向制表符   \\r 回车符   \\f 换页符   \\o 八进制数代表的字符   \\x 十六进制数代表的字符   \\0 表示一个空字符   \\|反斜杠    "},{"url":"/post/2017/oauth2/","title":"第三方登录","content":" 这篇文档的源自一个第三方登录的需求,于是我就想搞清楚怎么实现第三方登录的,网上有现成的解决方案: 友盟和ShareSDK;但是这不是我最需要,于是就有了下面的的记录:\n  阮一峰的网络日志之理解OAuth2.0这篇讲的很详细,可以先看下这个 QQ的OAuth2.0简介 微信登录功能官方文档(授权登录) "},{"url":"/post/2017/python-excel/","title":"Python和Excel的不解之缘","content":"表格处理模块  xlwt (writing xls files) xlrd (reading xls/xlsx files) openpyxl (reading/writing xlsx files) xlsxwriter (writing xlsx files) more details  xlwt 直接上干货, 重点看export_excel函数\n# -*- coding: utf-8 -*- import xlwt import functools from datetime import datetime def cost_time(method): @functools.wraps(method) def wrapper(self, *args, **kwargs): start_time = datetime.now() num = method(self, *args, **kwargs) end_time = datetime.now() print(u\u0026#34;导出%s条数据, 共消耗%s时间\u0026#34; % (num, str(end_time - start_time))) return wrapper @cost_time def export_excel(filename, header, content, *args, **kwargs): wb = xlwt.Workbook() if len(content) \u0026gt; 65536: raise Exception(u\u0026#34;你的数据量为%s, 超过65536, 拒绝通过xlwt导出\u0026#34; % len(content)) ws = wb.add_sheet(u\u0026#34;报表\u0026#34;) ws1 = wb.add_sheet(u\u0026#34;表2\u0026#34;) # 写表头 map(lambda h: ws.write(0, h[0], h[1]), enumerate(header)) # 写主体内容 map(lambda c: map(lambda sub_c: ws.write(c[0] + 1, sub_c[0], sub_c[1]), enumerate(c[1])), enumerate(content)) ws1.write(0, 0, u\u0026#34;test\u0026#34;) wb.save(filename) return len(content) if __name__ == \u0026#34;__main__\u0026#34;: header = (\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;) a = xrange(0, 77777*1) content = [(a[i], a[i+1], a[i+2], a[i+3], a[i+4], a[i+5], a[i+6]) for i in range(len(a))[::7]] export_excel(\u0026#34;test.xls\u0026#34;, header=header, content=content) xlrd 后续更新, 敬请期待\u0026hellip;\nopenpyxl 后续更新, 敬请期待\u0026hellip;\nxlsxwriter 后续更新, 敬请期待\u0026hellip;\n"},{"url":"/post/2017/mysql/","title":"mysql","content":"初涉Mysql MySQL概述  MySQL由瑞典MySQL AB公司开发，目前属于Oracle公司. MySQL是一个开源的关系型数据库管理系统. MySQL分为社区版和企业版.  MySQL的安装与配置 启动和停止MySQL  windows net start/stop mysql  linux service mysql start/stop   MySQL登录和退出  MySQL登录     参数 描述     -D, \u0026ndash;database=name 打开指定数据库   \u0026ndash;delimiter = name 指定分隔符   -h, \u0026ndash;host=name 服务器名称   -p, \u0026ndash;password[=name] 密码   -P, \u0026ndash;port=# 端口号   \u0026ndash;prompt=name 设置提示符   -u, \u0026ndash;user=name 打开指定数据库   -V, \u0026ndash;version 输出版本信息并且退出     MySQL退出  mysql \u0026gt; exit; mysql \u0026gt; quit; mysql \u0026gt; \\q;    修改MySQL提示符  MySQL提示符     参数 描述     \\D 完整的日期   \\d 当前数据库   \\h 服务器名称   \\u 当前用户      连接客户端时通过参数指定\nshell\u0026gt;mysql -uroot -proot --prompt 提示符   连接上客户端后，通过prompt命令修改\nmysql\u0026gt;prompt 提示符   MySQL常用命令   显示当前服务器版本\nSELECT VERSION();   显示当前日期时间\nSELECT NOW();   显示当前用户\nSELECT USER();    MySQL语句的规范\n  关键字和函数名称全部大写 数据库名称 表名称 字段名称全部小写 SQL语句必须以分号结尾  操作数据库  创建数据库 CREATE {DATABASE | SCHEMA} {IF NOT EXISTS} db_name [DEFAULT] CHARACTER SET [=] charset_name  查看当前服务器下的数据表列表 SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]  修改数据库 ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name  删除数据库 DROP {DATABASE | SCHEMA} [IF EXISTS] db_name   数据类型和操作数据表 数据类型  数据类型是指列、存储过程参数、表达式和局部变量的数字特征，它决定了数据的存储格式，代表了不同的信息类型。\n 整型    数据类型 存储范围 字节     TINYINT 有符号值: -128到127(-27到2^7-1)无符号值: 0到255(0到28-1) 1   SMALLINT 有符号值: -32768到32767(-215到2^15-1)无符号值: 0到65535(0到216-1) 2   MEDIUMINT 有符号值: -83886088到8388607(-223到2^23-1)无符号值: 0到16777215(0到224-1) 3   INT 有符号值: -2147483648到2147483648(-231到2^31-1)无符号值: 0到4294967295(0到232-1) 4   BIGINT 有符号值: -9223373036854775808到9223373036854775807(-263到2^63-1)无符号值: 0到18446744073709551615(0到264-1) 8    浮点型    数据类型 存储范围     FLOAT[(M,D)] -3.402823466E+38到-1.175494351E-38; 0和1.175494351E-38到3.402823466E+38.M是数字总位数, D是小数点后面的位数.如果M和D被省略, 根据硬件允许的限制来保存值.单精度浮点数精确到大约7位小数位.   DOUBLE[(M,D)] -1.7976931348623157E+308到-2.2250738585072014E-308; 0和2.2250738585072014E-308到1.7976931348623157E+308.    日期时间型    列类型 存储需求     YEAR 1   TIME 3   DATE 3   DATETIME 8   TIMESTAMP 4    字符型    列类型 存储需求     CHAR(M) M个字节, 0 \u0026lt;= M \u0026lt;= 255   VARCHAR(M) L+1个字节, 其中L \u0026lt;= M且0 \u0026lt;= M \u0026lt;= 65535   TINYTEXT L+1个字节, 其中L \u0026lt; 28   TEXT L+2个字节, 其中L \u0026lt; 216   MEDIUMTEXT L+3个字节, 其中L \u0026lt; 224   LONGTEXT L+4个字节, 其中L \u0026lt; 232   ENUM(\u0026lsquo;value1\u0026rsquo;, \u0026lsquo;value2\u0026rsquo;, \u0026hellip;) 1或2个字节, 取决于枚举值的个数(最多65535个值)   SET(\u0026lsquo;value1\u0026rsquo;, \u0026lsquo;value2\u0026rsquo;, \u0026hellip;) 1,2,3,4或者8个字节, 取决于set成员的数目(最多64个成员)    操作数据表 概述  数据表(或称表)是数据库最重要的组成部分之一，是其他对象的基础。  USE  打开数据库 USE 数据库名称;  创建数据表 CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, ... ) 查看数据表列表 SHOW TABLES [FROM db_name] [LIKE \u0026#39;pattern\u0026#39; | WHERE expr] 查看数据表结构 SHOW COLUMNS FROM tbl_name 插入记录 INSERT [INTO] tbl_name [(col_name,...)] VALUES (val,...) 记录查找 SELECT expr,... FROM tbl_name 空值与非空  NULL, 字段值可以为空 NOT NULL, 字段值禁止为空  AUTO_INCREMENT  自动编号，且必须与主键组合使用 默认情况下，起始值为1，每次增量为1  PRIMARY KEY  主键约束 每张数据表只能存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL  UNIQUE KEY  唯一约束 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值(NULL) 每张数据表可以存在多个唯一约束  DEFAULT  默认值 当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。  约束以及修改数据表 约束  约束保证数据的完整性和一致性。 约束分为表级约束和列级约束。 约束类型包括:  NOT NULL(非空约束) PRIMARY KEY(主键约束) UNIQUE KEY(唯一约束) DEFAULT(默认约束) FOREIGIN KEY(外键约束)    FOREIGN KEY  保持数据一致性，完整性 实现一对一或一对多关系。  外键约束的要求  父表和子表必须使用相同的存储引擎，而且禁止使用临时表。 数据表的存储引擎只能为InnoDB。 外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同;而字符的长度则可以不同。 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。  编辑数据表的默认存储引擎 MySQL配置文件 default-storage-engine=INNODB\n数据表的操作 操作数据表中的记录 子查询和连接 运算符和函数 自定义函数 MySQL存储过程 MySQL存储引擎 MySQL图形化管理工具"},{"url":"/post/2015/regex/","title":"Python3正则表达式特殊符号及用法(详细列表)","content":" 这篇文档整理自鱼C论坛, 感谢作者输出,我只是一枚搬运工\u0026hellip;\n  正则表达式的强大之处在于特殊符号的应用,特殊符号定义了字符集合、子组匹配、模式重复次数。正是这些特性符号使得一个正则表达式可以匹配字符串集合而不只是一个字符串。\n  注1: 为了便于理解，难点的地方均用斜体举了栗子。\n    字符 含义     . 表示匹配除了换行符外的任何字符 注: 通过设置re.DOTALL标志可以使.匹配任何字符(包括换行符)   ¦(竖杠) A¦(竖杠)B,表示匹配正则表达式A或者B   ^ 1.(脱字符)匹配输入字符串的开始位置 2.如果设置了re.MULTILINE标志,^也匹配换行符之后的位置   $ 1.匹配输入字符串的结束位置2.如果设置了re.MULTILINE标志,$也匹配换行符之前的位置   \\ 1.将一个普通字符变成特殊字符，例如 \\d 表示匹配所有十进制数字2. 解除元字符的特殊功能，例如 \\. 表示匹配点号本身3. 引用序号对应的子组所匹配的字符串4. 详见下方列举   [\u0026hellip;] 字符类，匹配所包含的任意一个字符注1：连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符注2：特殊字符仅有反斜线 \\ 保持特殊含义，用于转义字符。其它特殊字符如 *、+、? 等均作为普通字符匹配 注3：脱字符 ^ 如果出现在首位则表示匹配不包含其中的任意字符；如果 ^ 出现在字符串中间就仅作为普通字符匹配   {M,N} M 和 N 均为非负整数，其中 M \u0026lt;= N，表示前边的 RE 匹配 M ~ N 次注1：{M,} 表示至少匹配 M 次注2：{,N} 等价于 {0,N}注3：{N} 表示需要匹配 N 次   * 匹配前面的子表达式零次或多次，等价于 {0,}   + 匹配前面的子表达式一次或多次，等价于 {1,}   ? 匹配前面的子表达式零次或一次，等价于 {0,1}   *?, +?, ?? 默认情况下 *、+ 和 ? 的匹配模式是贪婪模式（即会尽可能多地匹配符合规则的字符串）；*?、+?和 ?? 表示启用对应的非贪婪模式。举个栗子：对于字符串 \u0026ldquo;FishCCC\u0026rdquo;，正则表达式 FishC+ 会匹配整个字符串，而 FishC+? 则匹配 \u0026ldquo;FishC\u0026rdquo;。   {M,N}? 同上，启用非贪婪模式，即只匹配 M 次   (\u0026hellip;) 匹配圆括号中的正则表达式，或者指定一个子组的开始和结束位置注：子组的内容可以在匹配之后被 \\数字 再次引用举个栗子：(\\w+) \\1 可以字符串 \u0026ldquo;FishC FishC.com\u0026rdquo; 中的 \u0026ldquo;FishC FishC\u0026rdquo;（注意有空格）   (?\u0026hellip;) (? 开头的表示为正则表达式的扩展语法（下边这些是 Python 支持的所有扩展语法）   (?aiLmsux) 1. (? 后可以紧跟着 \u0026lsquo;a\u0026rsquo;，\u0026lsquo;i\u0026rsquo;，\u0026lsquo;L\u0026rsquo;，\u0026rsquo;m'，\u0026rsquo;s'，\u0026lsquo;u\u0026rsquo;，\u0026lsquo;x\u0026rsquo; 中的一个或多个字符，只能在正则表达式的开头使用2. 每一个字符对应一种匹配标志：re-A（只匹配 ASCII 字符），re-I（忽略大小写），re-L（区域设置），re-M（多行模式）, re-S（. 匹配任何符号），re-X（详细表达式），包含这些字符将会影响整个正则表达式的规则3. 当你不想通过 re.compile() 设置正则表达式标志，这种方法就非常有用啦注意，由于 (?x) 决定正则表达式如何被解析，所以它应该总是被放在最前边（最多允许前边有空白符）。如果 (?x) 的前边是非空白字符，那么 (?x) 就发挥不了作用了。   (?:\u0026hellip;) 非捕获组，即该子组匹配的字符串无法从后边获取   (?P\u0026hellip;) 命名组，通过组的名字（name）即可访问到子组匹配的字符串   (?P=name) 反向引用一个命名组，它匹配指定命名组匹配的任何内容   (?#\u0026hellip;) 注释，括号中的内容将被忽略   (?=\u0026hellip;) 前向肯定断言。如果当前包含的正则表达式（这里以 \u0026hellip; 表示）在当前位置成功匹配，则代表成功，否则失败。一旦该部分正则表达式被匹配引擎尝试过，就不会继续进行匹配了；剩下的模式在此断言开始的地方继续尝试。举个栗子：love(?=FishC) 只匹配后边紧跟着 \u0026ldquo;FishC\u0026rdquo; 的字符串 \u0026ldquo;love\u0026rdquo;   (?!\u0026hellip;) 前向否定断言。这跟前向肯定断言相反（不匹配则表示成功，匹配表示失败）。举个栗子：FishC(?!.com) 只匹配后边不是 \u0026ldquo;.com\u0026rdquo; 的字符串 \u0026ldquo;FishC\u0026rdquo;   (?\u0026lt;=\u0026hellip;) 后向肯定断言。跟前向肯定断言一样，只是方向相反。举个栗子：(?\u0026lt;=love)FishC 只匹配前边紧跟着 \u0026ldquo;love\u0026rdquo; 的字符串 \u0026ldquo;FishC\u0026rdquo;   (?\u0026lt;!\u0026hellip;) 后向否定断言。跟前向肯定断言一样，只是方向相反。举个栗子：(?\u0026lt;!FishC).com 只匹配前边不是 \u0026ldquo;FishC\u0026rdquo; 的字符串 \u0026ldquo;.com\u0026rdquo;   (?(id/name)yes-pattern¦(竖杠)no-pattern) 1. 如果子组的序号或名字存在的话，则尝试 yes-pattern 匹配模式；否则尝试 no-pattern 匹配模式2. no-pattern 是可选的举个栗子：(\u0026lt;)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)\u0026gt;¦(竖杠)$) 是一个匹配邮件格式的正则表达式，可以匹配 \u0026lt;user@fishc.com\u0026gt; 和 \u0026lsquo;user@fishc.com\u0026rsquo;，但是不会匹配 \u0026lsquo;\u0026lt;user@fishc.com\u0026rsquo; 或 \u0026lsquo;user@fishc.com\u0026gt;'   \\ 下边列举了由字符 \u0026lsquo;' 和另一个字符组成的特殊含义。注意，'' + 元字符的组合可以解除元字符的特殊功能   \\序号 1. 引用序号对应的子组所匹配的字符串，子组的序号从 1 开始计算2. 如果序号是以 0 开头，或者 3 个数字的长度。那么不会被用于引用对应的子组，而是用于匹配八进制数字所表示的 ASCII 码值对应的字符举个栗子：(.+) \\1 会匹配 \u0026ldquo;FishC FishC\u0026rdquo; 或 \u0026ldquo;55 55\u0026rdquo;，但不会匹配 \u0026ldquo;FishCFishC\u0026rdquo;（注意，因为子组后边还有一个空格）   \\A 匹配输入字符串的开始位置   \\Z 匹配输入字符串的结束位置   \\b 匹配一个单词边界，单词被定义为 Unidcode 的字母数字或下横线字符举个栗子：\\bFishC\\b 会匹配字符串 \u0026ldquo;love FishC\u0026rdquo;、FishC.\u0026quot; 或 \u0026ldquo;(FishC)\u0026quot;   \\B 匹配非单词边界，其实就是与 \\b 相反举个栗子：py\\B 会匹配字符串 \u0026ldquo;python\u0026rdquo;、\u0026ldquo;py3\u0026rdquo; 或 \u0026ldquo;py2\u0026rdquo;，但不会匹配 \u0026ldquo;py \u0026ldquo;、\u0026ldquo;py.\u0026rdquo; 或 \u0026ldquo;py!\u0026quot;   \\d 1. 对于 Unicode（str 类型）模式：匹配任何一个数字，包括 [0-9] 和其他数字字符；如果开启了 re.ASCII 标志，就只匹配 [0-9]2. 对于 8 位（bytes 类型）模式：匹配 [0-9] 中任何一个数字   \\D 匹配任何非 Unicode 的数字，其实就是与 \\d 相反；如果开启了 re.ASCII 标志，则相当于匹配 [^0-9]   \\s 1. 对于 Unicode（str 类型）模式：匹配 Unicode 中的空白字符（包括 [ \\t\\n\\r\\f\\v] 以及其他空白字符）；如果开启了 re.ASCII 标志，就只匹配 [ \\t\\n\\r\\f\\v]2. 对于 8 位（bytes 类型）模式：匹配 ASCII 中定义的空白字符，即 [ \\t\\n\\r\\f\\v]   \\S 匹配任何非 Unicode 中的空白字符，其实就是与 \\s 相反；如果开启了 re.ASCII 标志，则相当于匹配 [^ \\t\\n\\r\\f\\v]   \\w 1. 对于 Unicode（str 类型）模式：匹配任何 Unicode 的单词字符，基本上所有语言的字符都可以匹配，当然也包括数字和下横线；如果开启了 re.ASCII 标志，就只匹配 [a-zA-Z0-9_]2. 对于 8 位（bytes 类型）模式：匹配 ASCII 中定义的字母数字，即 [a-zA-Z0-9_]   \\W 匹配任何非 Unicode 的单词字符，其实就是与 \\w 相反；如果开启了 re.ASCII 标志，则相当于 [^a-zA-Z0-9_]   转义符号 正则表达式还支持大部分 Python 字符串的转义符号：\\a，\\b，\\f，\\n，\\r，\\t，\\u，\\U，\\v，\\x，\\\u0026lt;br/\u0026gt;注1：\\b 通常用于匹配一个单词边界，只有在字符类中才表示“退格”注2：\\u 和 \\U 只有在 Unicode 模式下才会被识别注3：八进制转义（\\数字）是有限制的，如果第一个数字是 0，或者如果有 3 个八进制数字，那么就被认为是八进制数；其他情况则被认为是子组引用；至于字符串，八进制转义总是最多只能是 3 个数字的长度    "},{"url":"/post/2015/vim/","title":"Vim Cheat Sheet","content":"光标  h - 左移光标 j - 下移光标 k - 上移光标 l - 右移光标 w - 移动到下个单词开头 W - 移动到下个单词开头(单词含标点) e - 移动到下个单词结尾 E - 移动到下个单词结尾(单词含标点) b - 移动到上个单词结尾 B - 移动到上个单词结尾(单词含标点) 0 - 移动到行首 ^ - 移动到行首的非空白符 $ - 移动到行尾 G - 移动到文档末行行首 5G - 移动到第五行  Tip1 : 命令前追加数字表示命令的重复次数, 比如4j 表示向下移动四行\n插入模式 - 插入/追加文本  i - 从光标前开始插入字符 I - 从行首开始插入字符 a - 从光标后开始插入字符 A - 从行尾开始插入字符 o - 在当前行之下另起一行, 开始插入字符 O - 在当前行之上另起一行, 开始插入字符 ea - 从当前单词末尾开始插入 Esc - 退出插入模式  编辑  r - 替换当前字符 J - 将下一行合并到当前行 cc - 清空当前行, 然后进入插入模式 cw - 从光标位置开始, 修改单词 c$ - 从光标位置开始, 修改当前行 s - 删除当前字符, 然后进入插入模式 S - 清空当前行, 然后进入插入模式 (同cc) xp - 当前字符后移 u - 撤销 Ctrl + r - 重复 . - 再次执行上个命令  选择文本（可视化模式）  v - 进入可视化模式, 移动光标高亮选择, 然后可以对选择的文本执行命令(比如y-复制) V - 进入可视化模式(行粒度选择) o - 切换光标到选择区开头/结尾 Ctrl + v - 进入可视化模式(矩阵选择) O - 切换光标到选择区的角 aw - 选择当前单词 ab - 选择被 () 包裹的区域(含括号) aB - 选择被 {} 包裹的区域(含花括号) ib - 选择被 () 包裹的区域(不含括号) iB - 选择被 {} 包裹的区域(不含花括号) Esc - 退出可视化模式  可视化模式命令  \u0026lt; - 向左缩进 | \u0026gt; - 向右缩进 y - 复制 d - 剪切 ~ - 大小写切换  剪切, 复制, 粘贴  yy - 复制当前行 2yy - 复制 2 行 yw - 复制当前单词 y$ - 复制, 从光标位置到行末 p - 在光标后粘贴 P - 在光标前粘贴 dd - 剪切当前行 2dd - 剪切 2 行 dw - 剪切当前单词 D - 剪切, 从光标位置到行末 d$ - 剪切, 从光标位置到行末 (同D) x - 剪切当前字符  查找/替换  /pattern - 查找pattern ?pattern - 向上查找pattern n - 查找下一个 N - 查找上一个 :%s/old/new/g - 替换全部 :%s/old/new/gc - (逐个)替换  多文件  :e filename - 新建缓冲区打开 filename :bnext or :bn - 切换到下个缓冲区 :bprev or :bp - 切换到上个缓冲区 :bd - 关闭缓冲区 :sp filename - 新建缓冲区打开 filename 并水平分栏 :vsp filename - 新缓冲区打开 filename 并垂直分栏 Ctrl + ws - 水平分栏 Ctrl + ww - 在分栏间切换 Ctrl + wq - 关闭分栏 Ctrl + wv - 垂直分栏 Ctrl + wh - 切换到右侧分栏 Ctrl + wl - 切换到左侧分栏 Ctrl + wj - move cursor to the window below (horizontal split) Ctrl + wk - move cursor to the window above (horizontal split)  页签  :tabnew filename or :tabn filename - 创建新页签/在新标签页中打开文档 Ctrl + wT - 将分栏变成页签 gt or :tabnext or :tabn - 切换到下一个页签 gT or :tabprev or :tabp - 切换到上一个页签 Xgt - 切换到第X个页签 :tabmove # - 移动页签到第 # 位(下标从 0 开始) :tabclose or :tabc - 关闭当前页签 :tabonly or :tabo - 关闭其他页签  Tip2: \u0026ldquo;X\u0026quot;表示一个具体的数字\n退出  :w - 保存 :wq or :x or ZZ - 保存并退出 :q - 退出(修改未保存时警告) :q! or ZQ - 不保存强制退出  补充  nu 显示光标所在行号 set nu 显示所有行号  "}]